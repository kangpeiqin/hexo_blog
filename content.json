{"meta":{"title":"剪影","subtitle":null,"description":"The best preparation for tomorrow is doing your best today.","author":"KANGPEIQIN","url":"http://yoursite.com","root":"/"},"pages":[{},{},{}],"posts":[{"title":"PAT题解","date":"2019-07-22T14:45:46.000Z","path":"2019/07/22/pat/","text":"树与二叉树1020 Tree Traversals12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int MAXN=50; //最大的结点数 int n;int post[MAXN],in[MAXN];//用于保存后序和中序遍历结点的数组/*定义树结点结构*/struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right;&#125;;/*根据中序和后续递归创建树*/TreeNode *createTree(int postL,int postR,int inL,int inR) &#123; if(postL &gt; postR) &#123; //递归边界 return NULL; &#125; TreeNode *root = new TreeNode();//创建根结点 root-&gt;val = post[postR]; int k=0; for(k = 0; k &lt; n; k++) &#123; //计算出根结点在中序序列的位置 if(in[k]==post[postR]) &#123; break; &#125; &#125; int numberLeft = k-inL; //左子树的结点数 3 root-&gt;left = createTree(postL,postL+numberLeft-1,inL,inL+numberLeft-1); //下标是从0开始的 root-&gt;right = createTree(postL+numberLeft,postR-1,inL+numberLeft+1,inR); return root; &#125;/* 层序遍历 */void levelTraver(TreeNode* root)&#123; int count = 0; queue&lt;TreeNode*&gt; q;//创建一个队列 q.push(root); while(!q.empty())&#123; TreeNode* node = q.front(); //取出队列首结点 q.pop(); //弹出首结点 printf(&quot;%d&quot;,node-&gt;val); count++; if(count&lt;n) printf(&quot; &quot;); if(node-&gt;left)&#123; q.push(node-&gt;left); &#125; if(node-&gt;right)&#123; q.push(node-&gt;right); &#125; &#125; &#125; int main() &#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf(&quot;%d&quot;,&amp;post[i]); &#125; for(int i=0;i&lt;n;i++)&#123; scanf(&quot;%d&quot;,&amp;in[i]); &#125; TreeNode* root = createTree(0,n-1,0,n-1); levelTraver(root); return 0;&#125;","raw":"title: PAT题解\ncategories: Data Structure & Algorithm\ndate: 2019-07-22 22:45:46\n---\n---\n<!--more-->\n### 树与二叉树\n#### 1020 Tree Traversals\n```\n#include<cstdio>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nconst int MAXN=50; //最大的结点数 \nint n;\nint post[MAXN],in[MAXN];//用于保存后序和中序遍历结点的数组\n/*定义树结点结构*/\nstruct TreeNode {\n\tint val;\n\tstruct TreeNode *left;\n\tstruct TreeNode *right;\n};\n/*根据中序和后续递归创建树*/\nTreeNode *createTree(int postL,int postR,int inL,int inR) {\n\tif(postL > postR) { //递归边界\n\t\treturn NULL;\n\t}\n\tTreeNode *root = new TreeNode();//创建根结点\n\troot->val = post[postR];\n\tint k=0;\n\tfor(k = 0; k < n; k++) { //计算出根结点在中序序列的位置\n\t\tif(in[k]==post[postR]) {\n\t\t\tbreak;                \n\t\t}\n\t}\n\tint numberLeft = k-inL; //左子树的结点数 3\n\troot->left = createTree(postL,postL+numberLeft-1,inL,inL+numberLeft-1); //下标是从0开始的 \n\troot->right = createTree(postL+numberLeft,postR-1,inL+numberLeft+1,inR);\n\treturn root; \n}\n\n/* 层序遍历 */\nvoid levelTraver(TreeNode* root){\n\tint count = 0;\n\tqueue<TreeNode*> q;//创建一个队列 \n\tq.push(root);\n\twhile(!q.empty()){\n\t\tTreeNode* node = q.front(); //取出队列首结点 \n\t\tq.pop(); //弹出首结点 \n\t\tprintf(\"%d\",node->val);\n\t\tcount++;\n\t\tif(count<n) printf(\" \");\n\t\tif(node->left){\n\t\t\tq.push(node->left);\n\t\t}\n\t\tif(node->right){\n\t\t\tq.push(node->right);\n\t\t}\n\t}\n\t\n} \nint main() {\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&post[i]);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&in[i]);\n\t}\n\tTreeNode* root = createTree(0,n-1,0,n-1);\n\tlevelTraver(root);\n\treturn 0;\n}\n```\n","content":"<hr>\n<a id=\"more\"></a>\n<h3 id=\"树与二叉树\"><a href=\"#树与二叉树\" class=\"headerlink\" title=\"树与二叉树\"></a>树与二叉树</h3><h4 id=\"1020-Tree-Traversals\"><a href=\"#1020-Tree-Traversals\" class=\"headerlink\" title=\"1020 Tree Traversals\"></a>1020 Tree Traversals</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;cstdio&gt;</span><br><span class=\"line\">#include&lt;algorithm&gt;</span><br><span class=\"line\">#include&lt;queue&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">const int MAXN=50; //最大的结点数 </span><br><span class=\"line\">int n;</span><br><span class=\"line\">int post[MAXN],in[MAXN];//用于保存后序和中序遍历结点的数组</span><br><span class=\"line\">/*定义树结点结构*/</span><br><span class=\"line\">struct TreeNode &#123;</span><br><span class=\"line\">\tint val;</span><br><span class=\"line\">\tstruct TreeNode *left;</span><br><span class=\"line\">\tstruct TreeNode *right;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">/*根据中序和后续递归创建树*/</span><br><span class=\"line\">TreeNode *createTree(int postL,int postR,int inL,int inR) &#123;</span><br><span class=\"line\">\tif(postL &gt; postR) &#123; //递归边界</span><br><span class=\"line\">\t\treturn NULL;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tTreeNode *root = new TreeNode();//创建根结点</span><br><span class=\"line\">\troot-&gt;val = post[postR];</span><br><span class=\"line\">\tint k=0;</span><br><span class=\"line\">\tfor(k = 0; k &lt; n; k++) &#123; //计算出根结点在中序序列的位置</span><br><span class=\"line\">\t\tif(in[k]==post[postR]) &#123;</span><br><span class=\"line\">\t\t\tbreak;                </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint numberLeft = k-inL; //左子树的结点数 3</span><br><span class=\"line\">\troot-&gt;left = createTree(postL,postL+numberLeft-1,inL,inL+numberLeft-1); //下标是从0开始的 </span><br><span class=\"line\">\troot-&gt;right = createTree(postL+numberLeft,postR-1,inL+numberLeft+1,inR);</span><br><span class=\"line\">\treturn root; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 层序遍历 */</span><br><span class=\"line\">void levelTraver(TreeNode* root)&#123;</span><br><span class=\"line\">\tint count = 0;</span><br><span class=\"line\">\tqueue&lt;TreeNode*&gt; q;//创建一个队列 </span><br><span class=\"line\">\tq.push(root);</span><br><span class=\"line\">\twhile(!q.empty())&#123;</span><br><span class=\"line\">\t\tTreeNode* node = q.front(); //取出队列首结点 </span><br><span class=\"line\">\t\tq.pop(); //弹出首结点 </span><br><span class=\"line\">\t\tprintf(&quot;%d&quot;,node-&gt;val);</span><br><span class=\"line\">\t\tcount++;</span><br><span class=\"line\">\t\tif(count&lt;n) printf(&quot; &quot;);</span><br><span class=\"line\">\t\tif(node-&gt;left)&#123;</span><br><span class=\"line\">\t\t\tq.push(node-&gt;left);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif(node-&gt;right)&#123;</span><br><span class=\"line\">\t\t\tq.push(node-&gt;right);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;n);</span><br><span class=\"line\">\tfor(int i=0;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\tscanf(&quot;%d&quot;,&amp;post[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfor(int i=0;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\tscanf(&quot;%d&quot;,&amp;in[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tTreeNode* root = createTree(0,n-1,0,n-1);</span><br><span class=\"line\">\tlevelTraver(root);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","slug":"pat","excerpt":"","categories":[{"name":"Data Structure & Algorithm","slug":"Data-Structure-Algorithm","permalink":"http://yoursite.com/categories/Data-Structure-Algorithm/"}],"tags":[]},{"title":"版本控制工具的使用","date":"2019-06-16T07:00:55.000Z","path":"2019/06/16/subversion/","text":"概述在开发过程中，我们避免不了要管理我们编写的代码（比如要回退到某一时刻的版本、多人协作编写代码等），版本控制工具就是起到这样一个作用。版本控制系统有两种,一种是集中式，一种是分布式。集中式就是中央服务器保存所有文件的历史版本，我们通过客户端获取最新版本。分布式：每台电脑都保留着完整的历史版本，多人协同开发时通过推送的方式保持代码的一致。以下是通过虚拟机VMware中的CentOS进行的操作。 SVNCentOS安装svn服务器1# yum install subversion 创建版本库12# mkdir #创建目录# svnadmin create #将上面创建的目录指定为svn版本库 创建用户、配置相关的权限创建完成后，通过命令查看目录中的文件，发现svn为我们创建了：在这里我们主要关注conf目录中的三个文件passwd用于设置用户名和密码，authz主要用于设置组别和用户的权限，svnserve.conf用于全局设置（如匿名访问者的权限）。具体的配置可见每个文件当中的注释信息。这里不再赘述。最后启动服务：1# svnserve -d -r 目录 --listen-port 端口号 SVN默认监听端口号3690。 通过客户端进行访问下载TortoiseSVN客户端 并进行安装。常用的功能：Checkout（提取）:获取服务器上的源代码Commit（提交）:提交编写的代码Update (更新):从服务器上获取最新的代码版本Revert（版本回退）:撤销任何文件或目录里的局部更改 idea中配置svn最后，在IDE当中配置svn简化我们的日常的一些操作。","raw":"title: 版本控制工具的使用\ncategories: 版本控制\ndate: 2019-06-16 15:00:55\n---\n---\n<!--more-->\n# 概述\n在开发过程中，我们避免不了要管理我们编写的代码（比如要回退到某一时刻的版本、多人协作编写代码等），版本控制工具就是起到这样一个作用。版本控制系统有两种,一种是集中式，一种是分布式。集中式就是中央服务器保存所有文件的历史版本，我们通过客户端获取最新版本。分布式：每台电脑都保留着完整的历史版本，多人协同开发时通过推送的方式保持代码的一致。以下是通过虚拟机VMware中的CentOS进行的操作。\n# SVN\n\n## CentOS安装svn服务器\n```\n# yum install subversion\n```\n## 创建版本库\n```\n# mkdir   #创建目录\n# svnadmin create  #将上面创建的目录指定为svn版本库\n```\n## 创建用户、配置相关的权限\n创建完成后，通过命令查看目录中的文件，发现svn为我们创建了：![explanation](/uploads/svn1.png)在这里我们主要关注`conf`目录中的三个文件![explanation](/uploads/svn.png)`passwd`用于设置用户名和密码，`authz`主要用于设置组别和用户的权限，`svnserve.conf`用于全局设置（如匿名访问者的权限）。具体的配置可见每个文件当中的注释信息。这里不再赘述。\n最后启动服务：\n```\n# svnserve -d -r 目录 --listen-port 端口号\n```\nSVN默认监听端口号3690。\n\n## 通过客户端进行访问\n下载`TortoiseSVN客户端` 并进行安装。\n常用的功能：\n**Checkout（提取）**:获取服务器上的源代码 \n**Commit（提交）**:提交编写的代码\n**Update (更新)**:从服务器上获取最新的代码版本\n**Revert（版本回退）**:撤销任何文件或目录里的局部更改\n\n## idea中配置svn\n最后，在IDE当中配置svn简化我们的日常的一些操作。\n![explanation](/uploads/idea.png)\n","content":"<hr>\n<a id=\"more\"></a>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>在开发过程中，我们避免不了要管理我们编写的代码（比如要回退到某一时刻的版本、多人协作编写代码等），版本控制工具就是起到这样一个作用。版本控制系统有两种,一种是集中式，一种是分布式。集中式就是中央服务器保存所有文件的历史版本，我们通过客户端获取最新版本。分布式：每台电脑都保留着完整的历史版本，多人协同开发时通过推送的方式保持代码的一致。以下是通过虚拟机VMware中的CentOS进行的操作。</p>\n<h1 id=\"SVN\"><a href=\"#SVN\" class=\"headerlink\" title=\"SVN\"></a>SVN</h1><h2 id=\"CentOS安装svn服务器\"><a href=\"#CentOS安装svn服务器\" class=\"headerlink\" title=\"CentOS安装svn服务器\"></a>CentOS安装svn服务器</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># yum install subversion</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建版本库\"><a href=\"#创建版本库\" class=\"headerlink\" title=\"创建版本库\"></a>创建版本库</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># mkdir   #创建目录</span><br><span class=\"line\"># svnadmin create  #将上面创建的目录指定为svn版本库</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建用户、配置相关的权限\"><a href=\"#创建用户、配置相关的权限\" class=\"headerlink\" title=\"创建用户、配置相关的权限\"></a>创建用户、配置相关的权限</h2><p>创建完成后，通过命令查看目录中的文件，发现svn为我们创建了：<img src=\"/uploads/svn1.png\" alt=\"explanation\">在这里我们主要关注<code>conf</code>目录中的三个文件<img src=\"/uploads/svn.png\" alt=\"explanation\"><code>passwd</code>用于设置用户名和密码，<code>authz</code>主要用于设置组别和用户的权限，<code>svnserve.conf</code>用于全局设置（如匿名访问者的权限）。具体的配置可见每个文件当中的注释信息。这里不再赘述。<br>最后启动服务：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># svnserve -d -r 目录 --listen-port 端口号</span><br></pre></td></tr></table></figure></p>\n<p>SVN默认监听端口号3690。</p>\n<h2 id=\"通过客户端进行访问\"><a href=\"#通过客户端进行访问\" class=\"headerlink\" title=\"通过客户端进行访问\"></a>通过客户端进行访问</h2><p>下载<code>TortoiseSVN客户端</code> 并进行安装。<br>常用的功能：<br><strong>Checkout（提取）</strong>:获取服务器上的源代码<br><strong>Commit（提交）</strong>:提交编写的代码<br><strong>Update (更新)</strong>:从服务器上获取最新的代码版本<br><strong>Revert（版本回退）</strong>:撤销任何文件或目录里的局部更改</p>\n<h2 id=\"idea中配置svn\"><a href=\"#idea中配置svn\" class=\"headerlink\" title=\"idea中配置svn\"></a>idea中配置svn</h2><p>最后，在IDE当中配置svn简化我们的日常的一些操作。<br><img src=\"/uploads/idea.png\" alt=\"explanation\"></p>\n","slug":"subversion","excerpt":"","categories":[{"name":"版本控制","slug":"版本控制","permalink":"http://yoursite.com/categories/版本控制/"}],"tags":[]},{"title":"leetcode题解","date":"2019-05-10T01:13:00.000Z","path":"2019/05/10/leetcode题解/","text":"LinkedList常用的解题方法 遍历链表 利用递归的思想，如反转链表 双指针：快慢指针 Remove Duplicates from Sorted List思路：遍历链表，在遍历时判断当前结点的值与后面结点的值是否相等，时间复杂度O(n)。 12345678910111213class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; ListNode cur = head; //cur为遍历指针 while(cur != null&amp;&amp;cur.next != null)&#123; if(cur.val == cur.next.val)&#123; cur.next = curt.next.next; &#125;else &#123; cur = cur.next; &#125; &#125; return head; &#125;&#125; Remove Duplicates from Sorted List II思路：采用双指针，一个指针指向需要保留的结点，一个指针对有重复值的结点进行查找。123456789101112131415161718public ListNode deleteDuplicates(ListNode head) &#123; if(head == null) return head; ListNode dummy = new ListNode(0); dummy.next = head; //创建一个虚的头结点，方便后续的操作判断 ListNode pre = dummy,cur = head;//双指针，pre指向需要保留的结点，cur为查重指针 while(cur != null)&#123; while (cur.next != null&amp;&amp;cur.val == cur.next.val)&#123; //如果出现相等的结点，就把当前指针指到相等结点的最后一个,注意：并没有删除结点 cur = cur.next; &#125; if(pre.next == cur) &#123; //说明这是一个有唯一值的结点，cur指针还没有动过呢,通过cur指针是否有移动来判断是否存在等值结点 pre = pre.next; &#125; else&#123; //如果有一堆相等的结点，那就进行批量的删除 pre.next = cur.next; //这边pre指针没有动过哦，只是修改它指向的下一个的结点 &#125; cur = cur.next; &#125; return dummy.next;&#125; Linked List Cycle思路：采用快慢指针的思想。如果存在环，快指针终归会追上慢指针1234567891011public boolean hasCycle(ListNode head) &#123; if(head == null || head.next == null) return false; ListNode fast,slow; fast=slow = head; while(fast != null &amp;&amp; fast.next != null)&#123; //注意这边判断的写法，同时对前后两个结点进行判断 fast = fast.next.next;//fast每次走两步，slow每次走一步 slow = slow.next; if(fast == slow) return true; &#125; return false;&#125; Linked List Cycle II思路：与上题的思想基本一致。只是…看图：1234567891011121314151617181920public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; if (head == null || head.next == null) return null; ListNode fast, slow; fast = slow = head; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; if (fast == slow) &#123; fast = head; while (fast != slow) &#123; fast = fast.next; slow = slow.next; &#125; return fast; &#125; &#125; return null; &#125;&#125; Odd Even Linked List思路：采用双指针的思想，可以想象成分成两个链表，一个下标为偶数的链表，一个下标为奇数的链表，pre、cur分别指向两个链表的末尾结点。123456789101112131415class Solution &#123; public ListNode oddEvenList(ListNode head) &#123; if (head == null || head.next == null||head.next.next==null) return head; //结点为空，一个结点，两个结点的情况 ListNode pre = head, cur = head.next;//pre指向偶数链表的末结点，cur指向奇数链表的末结点。 while (cur != null &amp;&amp; cur.next != null) &#123; ListNode tmp = pre.next; //先保存要拼接的结点 pre.next = cur.next; cur.next = cur.next.next; //每次只进行一个结点的连接 pre.next.next=tmp; //进行拼接 cur = cur.next; pre = pre.next; &#125; return head; &#125;&#125; Palindrome Linked List思路：使用快慢指针和栈。通过快指针可以知道慢指针什么时候遍历到了中点。1234567891011121314151617181920class Solution &#123; public boolean isPalindrome(ListNode head) &#123; if (head == null || head.next == null) return true; ListNode slow = head, fast = head; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(head.val); while (fast.next != null &amp;&amp; fast.next.next != null) &#123; slow = slow.next; fast = fast.next.next; stack.push(slow.val); &#125; if (fast.next == null) stack.pop();//结点为奇数个的时候，需要将一个结点先弹出 while (slow.next != null) &#123; slow = slow.next; int tmp = stack.pop(); if (tmp != slow.val) return false; &#125; return true; &#125;&#125; Intersection of Two Linked Lists思路：一种方法是求得两条链表的结点个数差n，然后让长的链先走n，然后再同时遍历，比较两个结点的地址是相等。另一种方法是：通过环的思想，进行交叉遍历，让两个指针都走完相同的路程。1234567891011public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if (headA == null || headB == null) return null; ListNode p = headA, q = headB; while (p != q) &#123; p = p == null ? headB : p.next; q = q == null ? headA : q.next; &#125; return p; &#125;&#125; Sort List思路：采用快慢指针查找到中间结点，进行递归的归并排序12345678910111213141516171819202122232425class Solution &#123; public ListNode sortList(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode pre = head, slow = head, fast = head; while (fast != null &amp;&amp; fast.next != null) &#123; pre = slow; slow = slow.next; fast = fast.next.next; &#125; pre.next = null; return merge(sortList(head), sortList(slow)); &#125; ListNode merge(ListNode l1, ListNode l2) &#123; if (l1 == null) return l2; if (l2 == null) return l1; if (l1.val &lt; l2.val) &#123; l1.next = merge(l1.next, l2); return l1; &#125; else &#123; l2.next = merge(l1, l2.next); return l2; &#125; &#125;&#125; Delete Node in a Linked List思路：将要删除的结点的值设为下个结点的值，将下个结点删除。1234567class Solution &#123; public void deleteNode(ListNode node) &#123; ListNode q = node.next; node.val = q.val; node.next = q.next; &#125;&#125; String常用的解题方法 运用哈希 使用双指针 反转字符串 II思路：每隔2k个字符开始遍历，然后进行反转。123456789class Solution &#123; public: string reverseStr(string s, int k) &#123; for (int i = 0; i &lt; s.size(); i += 2 * k) &#123; reverse(s.begin() + i, min(s.begin() + i + k, s.end())); &#125; return s; &#125;&#125;; Implement strStr()思想：1.暴力破解，如果发生不匹配主串可能需要回溯。2.KMP算法。1234567891011121314151617class Solution &#123; public int strStr(String haystack, String needle) &#123; int i = 0, j = 0; int len1 = haystack.length(), len2 = needle.length(); while (i &lt; len1 &amp;&amp; j &lt; len2) &#123; if (haystack.charAt(i) == needle.charAt(j)) &#123; i++; j++; &#125; else &#123; i = i - j + 1; j = 0; &#125; &#125; if (j &gt;= len2) return i - j; else return -1; &#125;&#125; Valid Anagram思想：创建一个哈希数组，如果两个字符串含有同样的单词则将该位置的值置为0。123456789101112131415class Solution &#123; public boolean isAnagram(String s, String t) &#123; if (s.length() != t.length()) return false; if (s == null || t == null) return false; int[] map = new int[256]; for (int i = 0; i &lt; s.length(); i++) &#123; map[s.charAt(i)]++; map[t.charAt(i)]--; &#125; for (Integer i : map) &#123; if (i != 0) return false; &#125; return true; &#125;&#125; Valid Palindrome思路：采用双指针的思想，在这当中，使用了java提供的一些函数。1234567891011121314151617181920212223242526class Solution &#123; public boolean isPalindrome(String s) &#123; if (s == null || s.trim().isEmpty()) &#123; return true; &#125; int l = 0, r = s.length() - 1; while (l &lt; r) &#123; if (!Character.isLetterOrDigit(s.charAt(l))) &#123; //非字母或者数字的情况下。 l++; continue; &#125; if (!Character.isLetterOrDigit(s.charAt(r))) &#123; r--; continue; &#125; if (Character.toLowerCase(s.charAt(l)) == Character.toLowerCase(s.charAt(r))) &#123; l++; r--; &#125; else &#123; return false; &#125; &#125; return true; &#125;&#125; Array常用的解题方法 遍历数组，标记变量 双指针 PascalsTriangle123456789101112131415161718class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; numRows; i++) &#123; List&lt;Integer&gt; row = new ArrayList&lt;&gt;(); for (int j = 0; j &lt;= i; j++) &#123; if (i == 0 || j == 0 || i == j) &#123; row.add(1); &#125; else &#123; List&lt;Integer&gt; pre = res.get(i - 1); row.add(pre.get(j - 1) + pre.get(j)); &#125; &#125; res.add(row); &#125; return res; &#125;&#125; Remove Duplicates from Sorted Array思路：使用双指针，一个指针为遍历指针；另一个指针指向结果数组的每个位置，判断该位置要填充的元素。1234567891011class Solution &#123; public int removeDuplicates(int[] nums) &#123; int index = 0; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] != nums[index]) &#123; nums[++index] = nums[i];//0号位置的值已经确定，从1号位置开始 &#125; &#125; return index + 1; &#125;&#125; Remove Duplicates from Sorted Array II思路：同上题的思路相同，只是多一个变量count对元素的数量进行统计。123456789101112131415class Solution &#123; public int removeDuplicates(int[] nums) &#123; int index = 0, count = 0; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[index] == nums[i]) &#123; count++; if (count &lt; 2) nums[++index] = nums[i]; &#125; else &#123; count = 0; nums[++index] = nums[i]; &#125; &#125; return index + 1; &#125;&#125; Remove Element思路：双指针，在遍历时用另一个指针确定结果数组的每一个位置的最终值1234567891011class Solution &#123; public int removeElement(int[] nums, int val) &#123; int index = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] != val) &#123; nums[index++] = nums[i]; &#125; &#125; return index; &#125;&#125; Majority Element思路：设置变量majority存储可能是众数的元素，设置一个计数器count对元素的出现次数进行计数，在遍历数组的过程操作count变量进行一些操作。1234567891011121314class Solution &#123; public int majorityElement(int[] nums) &#123; int count = 0; int majority = nums[0]; for (int i = 0; i &lt; nums.length; i++) &#123; if (count == 0) majority = nums[i]; if (majority == nums[i]) count++; else &#123; count--; &#125; &#125; return majority; &#125;&#125; Search a 2D MatrixSearch a 2D Matrix II思路：根据题目的条件可知数组是有规律的，按照规律以某个元素所在行和列进行搜索，而减少对整个数组进行搜索。每个元素的行和列构成递增序列。123456789101112131415161718class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; int rows = matrix.length; if (rows == 0) return false; int cols = matrix[0].length; int i = 0, j = cols - 1; //右上角第一个元素的坐标 while (i &lt; rows &amp;&amp; j &gt;= 0) &#123; if (matrix[i][j] == target) &#123; return true; &#125; else if (matrix[i][j] &gt; target) &#123; j--; &#125; else &#123; i++; &#125; &#125; return false; &#125;&#125; Move Zeroes思路：先将前面非零数字进行填充，将数组之后空的位置填充上零。12345678910111213class Solution &#123; public void moveZeroes(int[] nums) &#123; int index = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] != 0) &#123; nums[index++] = nums[i]; &#125; &#125; for (int i = index; i &lt; nums.length; i++) &#123; nums[i] = 0; &#125; &#125;&#125; Intersection of Two Arrays思路：通过java提供的数据结构Set来帮助简化我们做题，用contains()方法啊，使得我们不用再去写遍历操作12345678910111213141516class Solution &#123; public int[] intersection(int[] nums1, int[] nums2) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); Set&lt;Integer&gt; res = new HashSet&lt;&gt;(); for(int n : nums1) set.add(n); for(int n : nums2) if(set.contains(n)) res.add(n); int[] result = new int[res.size()]; int index = 0 ; for(int n : res) result[index++] = n; return result; &#125;&#125; Intersection of Two Arrays II思路：设置一个hash数组统计数组当中每个元素出现的次数。1234567891011121314151617class Solution &#123; public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp;nums1, vector&lt;int&gt;&amp;nums2) &#123; vector&lt;int&gt; res; map&lt;int, int&gt; mp; for (int i = 0; i &lt; nums1.size(); i++) &#123; mp[nums1[i]]++; &#125; for (int i = 0; i &lt; nums2.size(); i++) &#123; if (mp[nums2[i]] &gt; 0) &#123; res.push_back(nums2[i]); mp[nums2[i]]--; &#125; &#125; return res; &#125;&#125;; Kth Largest Element in an Array思路：先进行排序，再得出结果123456class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; Arrays.sort(nums); return nums[nums.length - k]; &#125;&#125; stack需要掌握的思想 模拟进出栈 用栈解决问题的思想 Min Stack思路：用两个栈，一个栈为最小值栈，一个栈为真实数据栈。或者用一个栈也可以。12345678910111213141516171819202122232425262728293031323334class MinStack &#123; /** * initialize your data structure here. */ private Stack&lt;Integer&gt; min, data; //min为最小值栈。 public MinStack() &#123; //初始化两个栈 min = new Stack&lt;&gt;(); data = new Stack&lt;&gt;(); &#125; public void push(int x) &#123; data.push(x); if (min.empty() || min.peek() &gt;= x) &#123; min.push(x); &#125; &#125; public void pop() &#123; if ((int) data.peek() == (int) min.peek()) &#123; //通过peek()方法返回的为对象，两个不同的对象进行比较总是不相等的，所以需要进行强转。 min.pop(); &#125; data.pop(); &#125; public int top() &#123; return data.peek(); &#125; public int getMin() &#123; return min.peek(); &#125;&#125; TreeBinary Tree Preorder Traversal思路：非递归遍历，根据访问的顺序：根-&gt;左-&gt;右。1234567891011121314class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); if (root != null) stack.push(root); while (!stack.empty()) &#123; TreeNode node = stack.pop(); res.add(node.val); if (node.right != null) stack.push(node.right);//将还没访问的结点入栈 if (node.left != null) stack.push(node.left); &#125; return res; &#125;&#125; 递归写法：12345678910111213class Solution &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; if (root == null) &#123; return list; &#125; list.add(root.val); preorderTraversal(root.left); preorderTraversal(root.right); return list; &#125;&#125; Binary Tree Inorder Traversal非递归写法：123456789101112131415161718class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode node = root; while (!stack.empty() || node != null) &#123; if (node != null) &#123; stack.push(node); node = node.left; &#125; else &#123; node = stack.pop(); res.add(node.val); node = node.right; &#125; &#125; return res; &#125;&#125; 递归写法：12345678910111213class Solution &#123; List&lt;Integer&gt; list = new ArrayList(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; if (root == null) &#123; return list; &#125; inorderTraversal(root.left); list.add(root.val); inorderTraversal(root.right); return list; &#125;&#125; Binary Tree Postorder Traversal非递归写法：1234567891011121314151617181920212223242526class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode p = root, q = null; do &#123; while (p != null) &#123; //将左边的结点全部压入栈 stack.push(p); p = p.left; &#125; q = null; while (!stack.empty()) &#123; //查看出栈结点的右结点是否为空 p = stack.pop(); if (p.right == q) &#123; res.add(p.val); q = p; &#125; else &#123; stack.push(p); p = p.right; //转换成右边的结点 break; &#125; &#125; &#125; while (!stack.empty()); return res; &#125;&#125; 递归写法：12345678910111213class Solution &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; if (root == null) &#123; return list; &#125; postorderTraversal(root.left); postorderTraversal(root.right); list.add(root.val); return list; &#125;&#125; Kth Smallest Element in a BST思路：根据二叉搜索树的特性，选择用中序遍历的思想，设置变量统计当前访问到的结点，如果与所求结点k相等，则返回。12345678910111213141516171819class Solution &#123; int count = 0; TreeNode res; public int kthSmallest(TreeNode root, int k) &#123; InorderTraversal(root, k); return res.val; &#125; public void InorderTraversal(TreeNode root, int k) &#123; if (root.left != null) InorderTraversal(root.left, k); count++; if (count == k) &#123; res = root; return; &#125; if (root.right != null) InorderTraversal(root.right, k); &#125;&#125; Lowest Common Ancestor of a Binary Tree递归时需要建立总体的观念123456789class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null || p == root || q == root) return root; //当p和q当中有一个为根结点，则返回根结点 TreeNode left = lowestCommonAncestor(root.left, p, q); //递归时需要建立全局的观念 TreeNode right = lowestCommonAncestor(root.right, p, q); if(left!=null&amp;&amp;right!=null) return root; //若p、q在分在左右子树之间，则返回根结点 return left!=null ? left:right; //若p、q同在左子树或者右子树，则返回不为空的结点 &#125;&#125; Binary Tree Level Order Traversal思路：使用深度优先遍历或者辅助队列12345678910111213141516171819class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); dfs(root,0,res); return res; &#125; public void dfs(TreeNode root, int depth, List&lt;List&lt;Integer&gt;&gt; res) &#123; if (root != null) &#123; if (res.size() &lt; depth + 1) &#123; res.add(depth, new ArrayList&lt;Integer&gt;()); &#125; res.get(depth).add(root.val); depth++; if(root.left!=null) dfs(root.left,depth,res); if(root.right!=null) dfs(root.right,depth,res); &#125; &#125;&#125; Binary Tree Level Order Traversal II思路：和上一题的思路是一致的，只是在最后加入结果集时需要将其插入到头部。12345678910111213141516171819class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; LinkedList&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); if (root == null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = queue.size(); i &gt; 0; i--) &#123; TreeNode node = queue.poll(); list.add(node.val); if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); &#125; res.offerFirst(list); //将其插入到链表的头部 &#125; return res; &#125;&#125; Average of Levels in Binary Tree1234567891011121314151617181920class Solution &#123; public List&lt;Double&gt; averageOfLevels(TreeNode root) &#123; List&lt;Double&gt; res = new LinkedList&lt;&gt;(); if (root == null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) &#123; int size = queue.size(); double sum = 0; for (int i = size; i &gt; 0; i--) &#123; TreeNode node = queue.poll(); if (node != null) sum += node.val; if (node.left != null) queue.add(node.left); if (node.right != null) queue.add(node.right); &#125; res.add(sum / size); &#125; return res; &#125;&#125; N-ary Tree Level Order Traversal递归算法：1234567891011121314151617181920class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); dfs(root, 0, res); return res; &#125; public void dfs(Node root, int depth, List&lt;List&lt;Integer&gt;&gt; res) &#123; if (root != null) &#123; if (res.size() &lt; depth + 1) &#123; //根据层数判断需要创建多少个的List res.add(depth, new ArrayList&lt;Integer&gt;()); &#125; res.get(depth).add(root.val); //从特殊情况-&gt;一般情况 depth++; for (Node child : root.children) &#123; dfs(child, depth, res); &#125; &#125; &#125;&#125; 非递归算法：1234567891011121314151617181920class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (root == null) return res; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = queue.size(); i &gt; 0; i--) &#123; //一开始就必须获得队列的大小（队列是在不断变化的），队列当中当前层的全部结点 Node node = queue.poll(); list.add(node.val); for (Node child : node.children) &#123; queue.add(child); &#125; &#125; res.add(list); &#125; return res; &#125;&#125; Path Sum 12345678class Solution &#123; public boolean hasPathSum(TreeNode root, int sum) &#123; if (root == null) return false; sum -= root.val; if (root.right == null &amp;&amp; root.left == null) return sum == 0; //判断最后根节点到叶子结点的路径和是否为零。 return hasPathSum(root.left, sum) || hasPathSum(root.right, sum); &#125; Path Sum II123456789101112131415161718class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); helper(res,new ArrayList&lt;&gt;(),root,sum); return res; &#125; public void helper(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, TreeNode root, int sum) &#123; if (root == null) return; list.add(root.val); if (root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == sum) &#123; res.add(new ArrayList&lt;&gt;(list)); &#125; helper(res,list,root.left,sum-root.val); helper(res,list,root.right,sum-root.val); list.remove(list.size()-1); //进行回溯。 &#125;&#125; Path Sum III思路：1.计算以某个结点为路径起始点的符合条件数。2.遍历所有的结点，并递归执行1步骤。12345678910111213class Solution &#123;public: int pathSum(TreeNode* root, int sum) &#123; //遍历每个结点，每个结点都作为根计算路径 if (root == NULL) return 0; return helper(root, sum) + pathSum(root -&gt; left, sum) + pathSum(root -&gt; right, sum); &#125; int helper(TreeNode* root, int sum) &#123; //以root为根作为一条路径，计算该路径上符合条件的数目 if (root == NULL) return 0; sum -= root -&gt; val; //sum为0的情况下即是符合路径 return (sum == 0 ? 1 : 0) + helper(root -&gt; left, sum) + helper(root -&gt; right, sum); &#125;&#125;; 递归反转字符串123456789101112131415class Solution &#123; public void reverseString(char[] s) &#123; swap(0, s.length - 1, s); &#125; public void swap(int start, int end, char[] s) &#123; if (start &gt;= end) &#123; //递归边界 return; &#125; char tmp = s[start]; s[start] = s[end]; s[end] = tmp; swap(start + 1, end - 1, s); &#125;&#125; 两两交换链表中的节点1234567891011class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if (head == null || head.next == null) &#123; //递归边界 return head; &#125; ListNode next = head.next; //递归体 head.next = swapPairs(next.next); next.next = head; return next; &#125;&#125;","raw":"title: leetcode题解\ncategories:\n  - Data Structure & Algorithm\ndate: 2019-05-10 09:13:00\n---\n---\n<!--more-->\n## LinkedList\n常用的解题方法\n> * 遍历链表\n> * 利用递归的思想，如反转链表\n> * 双指针：快慢指针\n\n### [Remove Duplicates from Sorted List](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list)\n思路：遍历链表，在遍历时判断当前结点的值与后面结点的值是否相等，时间复杂度O(n)。\n\n``` java\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        ListNode cur = head; //cur为遍历指针\n        while(cur != null&&cur.next != null){\n            if(cur.val == cur.next.val){\n                cur.next = curt.next.next;\n            }else {\n                cur = cur.next;\n            }\n        }\n        return head;\n    }\n}\n```\n### [Remove Duplicates from Sorted List II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)\n思路：采用双指针，一个指针指向需要保留的结点，一个指针对有重复值的结点进行查找。\n``` java\n\t   public ListNode deleteDuplicates(ListNode head) {\n        if(head == null) return head;\n        ListNode dummy = new ListNode(0);\n        dummy.next = head; //创建一个虚的头结点，方便后续的操作判断\n        ListNode pre = dummy,cur = head;//双指针，pre指向需要保留的结点，cur为查重指针\n        while(cur != null){\n            while (cur.next != null&&cur.val == cur.next.val){ //如果出现相等的结点，就把当前指针指到相等结点的最后一个,注意：并没有删除结点\n                cur = cur.next;\n            }\n            if(pre.next == cur) {  //说明这是一个有唯一值的结点，cur指针还没有动过呢,通过cur指针是否有移动来判断是否存在等值结点\n                pre = pre.next;\n            } else{    //如果有一堆相等的结点，那就进行批量的删除\n                pre.next = cur.next; //这边pre指针没有动过哦，只是修改它指向的下一个的结点\n            }\n            cur = cur.next;\n        }\n        return dummy.next;\n    }\n```\n### [Linked List Cycle](https://leetcode-cn.com/problems/linked-list-cycle)\n思路：采用快慢指针的思想。如果存在环，快指针终归会追上慢指针\n``` java\n    public boolean hasCycle(ListNode head) {\n        if(head == null || head.next == null) return false;\n        ListNode fast,slow;\n        fast=slow = head;\n        while(fast != null && fast.next != null){ //注意这边判断的写法，同时对前后两个结点进行判断\n           fast = fast.next.next;//fast每次走两步，slow每次走一步\n           slow = slow.next;\n           if(fast == slow) return true;\n        }\n        return false;\n    }\n```\n### [Linked List Cycle II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\n思路：与上题的思想基本一致。只是...看图：\n![explanation](/uploads/LinkList.jpg)\n``` java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null) return null;\n        ListNode fast, slow;\n        fast = slow = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) {\n                fast = head;\n                while (fast != slow) {\n                    fast = fast.next;\n                    slow = slow.next;\n                }\n                return fast;\n            }\n        }\n        return null;\n    }\n}\n```\n### [Odd Even Linked List](https://leetcode-cn.com/problems/odd-even-linked-list/)\n思路：采用双指针的思想，可以想象成分成两个链表，一个下标为偶数的链表，一个下标为奇数的链表，pre、cur分别指向两个链表的末尾结点。\n```java\nclass Solution {\n    public ListNode oddEvenList(ListNode head) {\n        if (head == null || head.next == null||head.next.next==null) return head; //结点为空，一个结点，两个结点的情况\n        ListNode pre = head, cur = head.next;//pre指向偶数链表的末结点，cur指向奇数链表的末结点。\n        while (cur != null && cur.next != null) {\n            ListNode tmp = pre.next; //先保存要拼接的结点\n            pre.next = cur.next;\n            cur.next = cur.next.next; //每次只进行一个结点的连接\n            pre.next.next=tmp;  //进行拼接\n            cur = cur.next;\n            pre = pre.next;\n        }\n        return head;\n    }\n}\n```\n### [Palindrome Linked List](https://leetcode-cn.com/problems/palindrome-linked-list/)\n思路：使用快慢指针和栈。通过快指针可以知道慢指针什么时候遍历到了中点。\n```java\nclass Solution {\n    public boolean isPalindrome(ListNode head) {\n        if (head == null || head.next == null) return true;\n        ListNode slow = head, fast = head;\n        Stack<Integer> stack = new Stack<>();\n        stack.push(head.val);\n        while (fast.next != null && fast.next.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            stack.push(slow.val);\n        }\n        if (fast.next == null) stack.pop();//结点为奇数个的时候，需要将一个结点先弹出\n        while (slow.next != null) {\n            slow = slow.next;\n            int tmp = stack.pop();\n            if (tmp != slow.val) return false;\n        }\n        return true;\n    }\n}\n```\n### [Intersection of Two Linked Lists](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\n思路：一种方法是求得两条链表的结点个数差n，然后让长的链先走n，然后再同时遍历，比较两个结点的地址是相等。另一种方法是：通过环的思想，进行交叉遍历，让两个指针都走完相同的路程。\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) return null;\n        ListNode p = headA, q = headB;\n        while (p != q) {\n            p = p == null ? headB : p.next;\n            q = q == null ? headA : q.next;\n        }\n        return p;\n    }\n}\n```\n### [Sort List](https://leetcode-cn.com/problems/sort-list/)\n思路：采用快慢指针查找到中间结点，进行递归的归并排序\n```java\nclass Solution {\n    public ListNode sortList(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode pre = head, slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            pre = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        pre.next = null;\n        return merge(sortList(head), sortList(slow));\n    }\n\n    ListNode merge(ListNode l1, ListNode l2) {\n        if (l1 == null) return l2;\n        if (l2 == null) return l1;\n        if (l1.val < l2.val) {\n            l1.next = merge(l1.next, l2);\n            return l1;\n        } else {\n            l2.next = merge(l1, l2.next);\n            return l2;\n        }\n    }\n}\n```\n### [Delete Node in a Linked List](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)\n思路：将要删除的结点的值设为下个结点的值，将下个结点删除。\n```java\nclass Solution {\n    public void deleteNode(ListNode node) {\n        ListNode q = node.next;\n        node.val = q.val;\n        node.next = q.next;\n    }\n}\n```\n## String\n常用的解题方法\n> * 运用哈希\n> * 使用双指针\n### [ 反转字符串 II](https://leetcode-cn.com/problems/reverse-string-ii)\n思路：每隔2k个字符开始遍历，然后进行反转。\n``` C++\nclass Solution {\n    public:\n    string reverseStr(string s, int k) {\n        for (int i = 0; i < s.size(); i += 2 * k) {\n            reverse(s.begin() + i, min(s.begin() + i + k, s.end())); \n        }\n        return s;\n    }\n};\n```\n\n### [Implement strStr()](https://leetcode-cn.com/problems/implement-strstr/)\n思想：1.暴力破解，如果发生不匹配主串可能需要回溯。2.KMP算法。\n``` java\nclass Solution {\n    public int strStr(String haystack, String needle) {\n        int i = 0, j = 0;\n        int len1 = haystack.length(), len2 = needle.length();\n        while (i < len1 && j < len2) {\n            if (haystack.charAt(i) == needle.charAt(j)) {\n                i++;\n                j++;\n            } else {\n                i = i - j + 1;\n                j = 0;\n            }\n        }\n        if (j >= len2) return i - j;\n        else return -1;\n    }\n}\n```\n### [Valid Anagram](https://leetcode-cn.com/problems/valid-anagram/)\n思想：创建一个哈希数组，如果两个字符串含有同样的单词则将该位置的值置为0。\n``` java\nclass Solution {\n    public boolean isAnagram(String s, String t) {\n        if (s.length() != t.length()) return false;\n        if (s == null || t == null) return false;\n        int[] map = new int[256];\n        for (int i = 0; i < s.length(); i++) {\n            map[s.charAt(i)]++;\n            map[t.charAt(i)]--;\n        }\n        for (Integer i : map) {\n            if (i != 0) return false;\n        }\n        return true;\n    }\n}\n```\n### [Valid Palindrome](https://leetcode-cn.com/problems/valid-palindrome/)\n思路：采用双指针的思想，在这当中，使用了java提供的一些函数。\n```java\nclass Solution {\n    public boolean isPalindrome(String s) {\n        if (s == null || s.trim().isEmpty()) {\n            return true;\n        }\n        int l = 0, r = s.length() - 1;\n        while (l < r) {\n            if (!Character.isLetterOrDigit(s.charAt(l))) { //非字母或者数字的情况下。\n                l++;\n                continue;\n            }\n            if (!Character.isLetterOrDigit(s.charAt(r))) {\n                r--;\n                continue;\n            }\n            if (Character.toLowerCase(s.charAt(l)) == Character.toLowerCase(s.charAt(r))) {\n                l++;\n                r--;\n            } else {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n```\n## Array\n常用的解题方法\n> * 遍历数组，标记变量\n> * 双指针\n### [PascalsTriangle](https://leetcode-cn.com/problems/pascals-triangle/)\n```\nclass Solution {\n    public List<List<Integer>> generate(int numRows) {\n        List<List<Integer>> res = new ArrayList<>();\n        for (int i = 0; i < numRows; i++) {\n            List<Integer> row = new ArrayList<>();\n            for (int j = 0; j <= i; j++) {\n                if (i == 0 || j == 0 || i == j) {\n                    row.add(1);\n                } else {\n                    List<Integer> pre = res.get(i - 1);\n                    row.add(pre.get(j - 1) + pre.get(j));\n                }\n            }\n            res.add(row);\n        }\n        return res;\n    }\n}\n```\n### [Remove Duplicates from Sorted Array](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)\n思路：使用双指针，一个指针为遍历指针；另一个指针指向结果数组的每个位置，判断该位置要填充的元素。\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int index = 0;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] != nums[index]) {\n                nums[++index] = nums[i];//0号位置的值已经确定，从1号位置开始\n            }\n        }\n        return index + 1;\n    }\n}\n```\n### [Remove Duplicates from Sorted Array II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)\n思路：同上题的思路相同，只是多一个变量count对元素的数量进行统计。\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int index = 0, count = 0;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[index] == nums[i]) {\n                count++;\n                if (count < 2) nums[++index] = nums[i];\n            } else {\n                count = 0;\n                nums[++index] = nums[i];\n            }\n        }\n        return index + 1;\n    }\n}\n```\n### [Remove Element](https://leetcode-cn.com/problems/remove-element/)\n思路：双指针，在遍历时用另一个指针确定结果数组的每一个位置的最终值\n```java\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        int index = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] != val) {\n                nums[index++] = nums[i];\n            }\n        }\n        return index;\n    }\n}\n```\n### [Majority Element](https://leetcode-cn.com/problems/majority-element/)\n思路：设置变量majority存储可能是众数的元素，设置一个计数器count对元素的出现次数进行计数，在遍历数组的过程操作count变量进行一些操作。\n```java\nclass Solution {\n    public int majorityElement(int[] nums) {\n        int count = 0;\n        int majority = nums[0];\n        for (int i = 0; i < nums.length; i++) {\n            if (count == 0) majority = nums[i];\n            if (majority == nums[i]) count++;\n            else {\n                count--;\n            }\n        }\n        return majority;\n    }\n}\n```\n### [Search a 2D Matrix](https://leetcode-cn.com/problems/search-a-2d-matrix/)\n[Search a 2D Matrix II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)\n思路：根据题目的条件可知数组是有规律的，按照规律以某个元素所在行和列进行搜索，而减少对整个数组进行搜索。每个元素的行和列构成递增序列。\n```java\nclass Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        int rows = matrix.length;\n        if (rows == 0) return false;\n        int cols = matrix[0].length;\n        int i = 0, j = cols - 1;  //右上角第一个元素的坐标\n        while (i < rows && j >= 0) {\n            if (matrix[i][j] == target) {\n                return true;\n            } else if (matrix[i][j] > target) {\n                j--;\n            } else {\n                i++;\n            }\n        }\n        return false;\n    }\n}\n```\n### [Move Zeroes](https://leetcode-cn.com/problems/move-zeroes/)\n思路：先将前面非零数字进行填充，将数组之后空的位置填充上零。\n```java\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int index = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] != 0) {\n                nums[index++] = nums[i];\n            }\n        }\n        for (int i = index; i < nums.length; i++) {\n            nums[i] = 0;\n        }\n    }\n}\n```\n### [Intersection of Two Arrays](https://leetcode-cn.com/problems/intersection-of-two-arrays/)\n思路：通过java提供的数据结构Set来帮助简化我们做题，用contains()方法啊，使得我们不用再去写遍历操作\n```java\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        Set<Integer> set = new HashSet<>();\n        Set<Integer> res = new HashSet<>();\n        for(int n : nums1)\n            set.add(n);\n        for(int n : nums2)\n            if(set.contains(n))\n                res.add(n);\n        int[] result = new int[res.size()];\n        int index = 0 ;\n        for(int n : res)\n            result[index++] = n;\n        return result;\n    }\n}\n```\n### [Intersection of Two Arrays II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)\n思路：设置一个hash数组统计数组当中每个元素出现的次数。\n``` C++\nclass Solution {\n    public:\n    vector<int> intersect(vector<int>&nums1, vector<int>&nums2) {\n        vector<int> res;\n        map<int, int> mp;\n        for (int i = 0; i < nums1.size(); i++) {\n            mp[nums1[i]]++;\n        }\n        for (int i = 0; i < nums2.size(); i++) {\n            if (mp[nums2[i]] > 0) {\n                res.push_back(nums2[i]);\n                mp[nums2[i]]--;\n            }\n        }\n        return res;\n    }\n};\n```\n### [Kth Largest Element in an Array](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)\n思路：先进行排序，再得出结果\n```java\nclass Solution {\n    public int findKthLargest(int[] nums, int k) {\n        Arrays.sort(nums);\n        return nums[nums.length - k];\n    }\n}\n```\n## stack\n需要掌握的思想\n> * 模拟进出栈\n> * 用栈解决问题的思想\n### [Min Stack](https://leetcode-cn.com/problems/min-stack/submissions/)\n思路：用两个栈，一个栈为最小值栈，一个栈为真实数据栈。或者用一个栈也可以。\n```java\nclass MinStack {\n\n    /**\n     * initialize your data structure here.\n     */\n    private Stack<Integer> min, data; //min为最小值栈。\n\n    public MinStack() {  //初始化两个栈\n        min = new Stack<>();\n        data = new Stack<>();\n    }\n\n    public void push(int x) {\n        data.push(x);\n        if (min.empty() || min.peek() >= x) {\n            min.push(x);\n        }\n    }\n\n    public void pop() {\n        if ((int) data.peek() == (int) min.peek()) { //通过peek()方法返回的为对象，两个不同的对象进行比较总是不相等的，所以需要进行强转。\n            min.pop();\n        }\n        data.pop();\n    }\n\n    public int top() {\n        return data.peek();\n    }\n\n    public int getMin() {\n        return min.peek();\n    }\n}\n```\n## Tree\n### [Binary Tree Preorder Traversal](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)\n思路：非递归遍历，根据访问的顺序：根->左->右。\n```java\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        Stack<TreeNode> stack = new Stack<>();\n        if (root != null) stack.push(root);\n        while (!stack.empty()) {\n            TreeNode node = stack.pop();\n            res.add(node.val);\n            if (node.right != null) stack.push(node.right);//将还没访问的结点入栈\n            if (node.left != null) stack.push(node.left);\n        }\n        return res;\n    }\n}\n```\n递归写法：\n```java\nclass Solution {\n    List<Integer> list = new ArrayList<>();\n\n    public List<Integer> preorderTraversal(TreeNode root) {\n        if (root == null) {\n            return list;\n        }\n        list.add(root.val);\n        preorderTraversal(root.left);\n        preorderTraversal(root.right);\n        return list;\n    }\n}\n```\n### [Binary Tree Inorder Traversal](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)\n非递归写法：\n```java\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        Stack<TreeNode> stack = new Stack<>();\n        TreeNode node = root;\n        while (!stack.empty() || node != null) {\n            if (node != null) {\n                stack.push(node);\n                node = node.left;\n            } else {\n                node = stack.pop();\n                res.add(node.val);\n                node = node.right;\n            }\n        }\n        return res;\n    }\n}\n```\n递归写法：\n```java\nclass Solution {\n    List<Integer> list = new ArrayList();\n\n    public List<Integer> inorderTraversal(TreeNode root) {\n        if (root == null) {\n            return list;\n        }\n        inorderTraversal(root.left);\n        list.add(root.val);\n        inorderTraversal(root.right);\n        return list;\n    }\n}\n```\n### [Binary Tree Postorder Traversal](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)\n非递归写法：\n```java\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        Stack<TreeNode> stack = new Stack<>();\n        TreeNode p = root, q = null;\n        do {\n            while (p != null) {  //将左边的结点全部压入栈\n                stack.push(p);\n                p = p.left;\n            }\n            q = null;\n            while (!stack.empty()) {  //查看出栈结点的右结点是否为空\n                p = stack.pop();\n                if (p.right == q) {\n                    res.add(p.val);\n                    q = p;\n                } else {\n                    stack.push(p);\n                    p = p.right; //转换成右边的结点\n                    break;\n                }\n            }\n        } while (!stack.empty());\n        return res;\n    }\n}\n```\n递归写法：\n```java\nclass Solution {\n    List<Integer> list = new ArrayList<>();\n\n    public List<Integer> postorderTraversal(TreeNode root) {\n        if (root == null) {\n            return list;\n        }\n        postorderTraversal(root.left);\n        postorderTraversal(root.right);\n        list.add(root.val);\n        return list;\n    }\n}\n```\n### [Kth Smallest Element in a BST](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)\n思路：根据二叉搜索树的特性，选择用中序遍历的思想，设置变量统计当前访问到的结点，如果与所求结点k相等，则返回。\n```java\nclass Solution {\n    int count = 0;\n    TreeNode res;\n\n    public int kthSmallest(TreeNode root, int k) {\n        InorderTraversal(root, k);\n        return res.val;\n    }\n\n    public void InorderTraversal(TreeNode root, int k) {\n        if (root.left != null) InorderTraversal(root.left, k);\n        count++;\n        if (count == k) {\n            res = root;\n            return;\n        }\n        if (root.right != null) InorderTraversal(root.right, k);\n    }\n}\n```\n### [Lowest Common Ancestor of a Binary Tree](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)\n递归时需要建立总体的观念\n```java\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null || p == root || q == root) return root;  //当p和q当中有一个为根结点，则返回根结点\n        TreeNode left = lowestCommonAncestor(root.left, p, q); //递归时需要建立全局的观念\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\n        if(left!=null&&right!=null) return root; //若p、q在分在左右子树之间，则返回根结点\n        return left!=null ? left:right; //若p、q同在左子树或者右子树，则返回不为空的结点\n    }\n}\n```\n### [Binary Tree Level Order Traversal]()\n思路：使用深度优先遍历或者辅助队列\n```\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<>();\n        dfs(root,0,res);\n        return res;\n    }\n\n    public void dfs(TreeNode root, int depth, List<List<Integer>> res) {\n        if (root != null) {\n            if (res.size() < depth + 1) {\n                res.add(depth, new ArrayList<Integer>());\n            }\n            res.get(depth).add(root.val);\n            depth++;\n            if(root.left!=null) dfs(root.left,depth,res);\n            if(root.right!=null) dfs(root.right,depth,res);\n        }\n    }\n}\n```\n### [Binary Tree Level Order Traversal II]()\n思路：和上一题的思路是一致的，只是在最后加入结果集时需要将其插入到头部。\n```\nclass Solution {\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\n        LinkedList<List<Integer>> res = new LinkedList<>();\n        if (root == null) return res;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            List<Integer> list = new ArrayList<>();\n            for (int i = queue.size(); i > 0; i--) {\n                TreeNode node = queue.poll();\n                list.add(node.val);\n                if (node.left != null) queue.offer(node.left);\n                if (node.right != null) queue.offer(node.right);\n            }\n            res.offerFirst(list); //将其插入到链表的头部\n        }\n        return res;\n    }\n}\n```\n### [Average of Levels in Binary Tree]()\n```\nclass Solution {\n    public List<Double> averageOfLevels(TreeNode root) {\n        List<Double> res = new LinkedList<>();\n        if (root == null) return res;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            double sum = 0;\n            for (int i = size; i > 0; i--) {\n                TreeNode node = queue.poll();\n                if (node != null) sum += node.val;\n                if (node.left != null) queue.add(node.left);\n                if (node.right != null) queue.add(node.right);\n            }\n            res.add(sum / size);\n        }\n        return res;\n    }\n}\n```\n\n### [N-ary Tree Level Order Traversal]()\n递归算法：\n```\nclass Solution {\n    public List<List<Integer>> levelOrder(Node root) {\n        List<List<Integer>> res = new ArrayList<>();\n        dfs(root, 0, res);\n        return res;\n    }\n\n    public void dfs(Node root, int depth, List<List<Integer>> res) {\n        if (root != null) {\n            if (res.size() < depth + 1) {  //根据层数判断需要创建多少个的List\n                res.add(depth, new ArrayList<Integer>());\n            }\n            res.get(depth).add(root.val);    //从特殊情况->一般情况\n            depth++;\n            for (Node child : root.children) {\n                dfs(child, depth, res);\n            }\n        }\n    }\n}\n```\n非递归算法：\n```\nclass Solution {\n    public List<List<Integer>> levelOrder(Node root) {\n        List<List<Integer>> res = new ArrayList<>();\n        if (root == null) return res;\n        Queue<Node> queue = new LinkedList<>();\n        queue.add(root);\n        while (!queue.isEmpty()) {\n            List<Integer> list = new ArrayList<>();\n            for (int i = queue.size(); i > 0; i--) {  //一开始就必须获得队列的大小（队列是在不断变化的），队列当中当前层的全部结点\n                Node node = queue.poll();\n                list.add(node.val);\n                for (Node child : node.children) {\n                    queue.add(child);\n                }\n            }\n            res.add(list);\n        }\n        return res;\n    }\n}\n```\n### [Path Sum ]()\n```\nclass Solution {\n    public boolean hasPathSum(TreeNode root, int sum) {\n        if (root == null)\n            return false;\n        sum -= root.val;\n        if (root.right == null && root.left == null) return sum == 0; //判断最后根节点到叶子结点的路径和是否为零。\n        return hasPathSum(root.left, sum) || hasPathSum(root.right, sum);\n    }\n```\n### [Path Sum II]()\n```\nclass Solution {\n    public List<List<Integer>> pathSum(TreeNode root, int sum) {\n        List<List<Integer>> res = new ArrayList<>();\n        helper(res,new ArrayList<>(),root,sum);\n        return res;\n    }\n\n    public void helper(List<List<Integer>> res, List<Integer> list, TreeNode root, int sum) {\n        if (root == null) return;\n        list.add(root.val);\n        if (root.left == null && root.right == null && root.val == sum) {\n            res.add(new ArrayList<>(list));\n        }\n        helper(res,list,root.left,sum-root.val);\n        helper(res,list,root.right,sum-root.val);\n        list.remove(list.size()-1); //进行回溯。\n    }\n}\n```\n### [Path Sum III]()\n思路：1.计算以某个结点为路径起始点的符合条件数。2.遍历所有的结点，并递归执行1步骤。\n```\nclass Solution {\npublic:\n    int pathSum(TreeNode* root, int sum) { //遍历每个结点，每个结点都作为根计算路径\n        if (root == NULL) return 0;\n        return helper(root, sum) + pathSum(root -> left, sum) + pathSum(root -> right, sum);\n    }\n\n    int helper(TreeNode* root, int sum) { //以root为根作为一条路径，计算该路径上符合条件的数目\n        if (root == NULL) return 0;\n        sum -= root -> val; //sum为0的情况下即是符合路径\n        return (sum == 0 ? 1 : 0) + helper(root -> left, sum) + helper(root -> right, sum);\n    }\n};\n```\n## 递归\n### [反转字符串](https://leetcode.com/problems/reverse-string/)\n```\nclass Solution {\n    public void reverseString(char[] s) {\n        swap(0, s.length - 1, s);\n    }\n\n    public void swap(int start, int end, char[] s) {\n        if (start >= end) {  //递归边界\n            return;\n        }\n        char tmp = s[start];\n        s[start] = s[end];\n        s[end] = tmp;\n        swap(start + 1, end - 1, s);\n    }\n}\n```\n### [两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs)\n``` java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {  //递归边界\n            return head;\n        }\n        ListNode next = head.next;  //递归体\n        head.next = swapPairs(next.next);\n        next.next = head;\n        return next;\n    }\n}\n```","content":"<hr>\n<a id=\"more\"></a>\n<h2 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h2><p>常用的解题方法</p>\n<blockquote>\n<ul>\n<li>遍历链表</li>\n<li>利用递归的思想，如反转链表</li>\n<li>双指针：快慢指针</li>\n</ul>\n</blockquote>\n<h3 id=\"Remove-Duplicates-from-Sorted-List\"><a href=\"#Remove-Duplicates-from-Sorted-List\" class=\"headerlink\" title=\"Remove Duplicates from Sorted List\"></a><a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list\" target=\"_blank\" rel=\"noopener\">Remove Duplicates from Sorted List</a></h3><p>思路：遍历链表，在遍历时判断当前结点的值与后面结点的值是否相等，时间复杂度O(n)。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">deleteDuplicates</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        ListNode cur = head; <span class=\"comment\">//cur为遍历指针</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur != <span class=\"keyword\">null</span>&amp;&amp;cur.next != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cur.val == cur.next.val)&#123;</span><br><span class=\"line\">                cur.next = curt.next.next;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                cur = cur.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Remove-Duplicates-from-Sorted-List-II\"><a href=\"#Remove-Duplicates-from-Sorted-List-II\" class=\"headerlink\" title=\"Remove Duplicates from Sorted List II\"></a><a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/\" target=\"_blank\" rel=\"noopener\">Remove Duplicates from Sorted List II</a></h3><p>思路：采用双指针，一个指针指向需要保留的结点，一个指针对有重复值的结点进行查找。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">deleteDuplicates</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    ListNode dummy = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">    dummy.next = head; <span class=\"comment\">//创建一个虚的头结点，方便后续的操作判断</span></span><br><span class=\"line\">    ListNode pre = dummy,cur = head;<span class=\"comment\">//双指针，pre指向需要保留的结点，cur为查重指针</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cur != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur.next != <span class=\"keyword\">null</span>&amp;&amp;cur.val == cur.next.val)&#123; <span class=\"comment\">//如果出现相等的结点，就把当前指针指到相等结点的最后一个,注意：并没有删除结点</span></span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pre.next == cur) &#123;  <span class=\"comment\">//说明这是一个有唯一值的结点，cur指针还没有动过呢,通过cur指针是否有移动来判断是否存在等值结点</span></span><br><span class=\"line\">            pre = pre.next;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span>&#123;    <span class=\"comment\">//如果有一堆相等的结点，那就进行批量的删除</span></span><br><span class=\"line\">            pre.next = cur.next; <span class=\"comment\">//这边pre指针没有动过哦，只是修改它指向的下一个的结点</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur = cur.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dummy.next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Linked-List-Cycle\"><a href=\"#Linked-List-Cycle\" class=\"headerlink\" title=\"Linked List Cycle\"></a><a href=\"https://leetcode-cn.com/problems/linked-list-cycle\" target=\"_blank\" rel=\"noopener\">Linked List Cycle</a></h3><p>思路：采用快慢指针的思想。如果存在环，快指针终归会追上慢指针<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    ListNode fast,slow;</span><br><span class=\"line\">    fast=slow = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast != <span class=\"keyword\">null</span> &amp;&amp; fast.next != <span class=\"keyword\">null</span>)&#123; <span class=\"comment\">//注意这边判断的写法，同时对前后两个结点进行判断</span></span><br><span class=\"line\">       fast = fast.next.next;<span class=\"comment\">//fast每次走两步，slow每次走一步</span></span><br><span class=\"line\">       slow = slow.next;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(fast == slow) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Linked-List-Cycle-II\"><a href=\"#Linked-List-Cycle-II\" class=\"headerlink\" title=\"Linked List Cycle II\"></a><a href=\"https://leetcode-cn.com/problems/linked-list-cycle-ii/\" target=\"_blank\" rel=\"noopener\">Linked List Cycle II</a></h3><p>思路：与上题的思想基本一致。只是…看图：<br><img src=\"/uploads/LinkList.jpg\" alt=\"explanation\"><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">detectCycle</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        ListNode fast, slow;</span><br><span class=\"line\">        fast = slow = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (fast != <span class=\"keyword\">null</span> &amp;&amp; fast.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fast == slow) &#123;</span><br><span class=\"line\">                fast = head;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (fast != slow) &#123;</span><br><span class=\"line\">                    fast = fast.next;</span><br><span class=\"line\">                    slow = slow.next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> fast;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Odd-Even-Linked-List\"><a href=\"#Odd-Even-Linked-List\" class=\"headerlink\" title=\"Odd Even Linked List\"></a><a href=\"https://leetcode-cn.com/problems/odd-even-linked-list/\" target=\"_blank\" rel=\"noopener\">Odd Even Linked List</a></h3><p>思路：采用双指针的思想，可以想象成分成两个链表，一个下标为偶数的链表，一个下标为奇数的链表，pre、cur分别指向两个链表的末尾结点。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">oddEvenList</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>||head.next.next==<span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> head; <span class=\"comment\">//结点为空，一个结点，两个结点的情况</span></span><br><span class=\"line\">        ListNode pre = head, cur = head.next;<span class=\"comment\">//pre指向偶数链表的末结点，cur指向奇数链表的末结点。</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur != <span class=\"keyword\">null</span> &amp;&amp; cur.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ListNode tmp = pre.next; <span class=\"comment\">//先保存要拼接的结点</span></span><br><span class=\"line\">            pre.next = cur.next;</span><br><span class=\"line\">            cur.next = cur.next.next; <span class=\"comment\">//每次只进行一个结点的连接</span></span><br><span class=\"line\">            pre.next.next=tmp;  <span class=\"comment\">//进行拼接</span></span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">            pre = pre.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Palindrome-Linked-List\"><a href=\"#Palindrome-Linked-List\" class=\"headerlink\" title=\"Palindrome Linked List\"></a><a href=\"https://leetcode-cn.com/problems/palindrome-linked-list/\" target=\"_blank\" rel=\"noopener\">Palindrome Linked List</a></h3><p>思路：使用快慢指针和栈。通过快指针可以知道慢指针什么时候遍历到了中点。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        ListNode slow = head, fast = head;</span><br><span class=\"line\">        Stack&lt;Integer&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        stack.push(head.val);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (fast.next != <span class=\"keyword\">null</span> &amp;&amp; fast.next.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">            stack.push(slow.val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fast.next == <span class=\"keyword\">null</span>) stack.pop();<span class=\"comment\">//结点为奇数个的时候，需要将一个结点先弹出</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (slow.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = stack.pop();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tmp != slow.val) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Intersection-of-Two-Linked-Lists\"><a href=\"#Intersection-of-Two-Linked-Lists\" class=\"headerlink\" title=\"Intersection of Two Linked Lists\"></a><a href=\"https://leetcode-cn.com/problems/intersection-of-two-linked-lists/\" target=\"_blank\" rel=\"noopener\">Intersection of Two Linked Lists</a></h3><p>思路：一种方法是求得两条链表的结点个数差n，然后让长的链先走n，然后再同时遍历，比较两个结点的地址是相等。另一种方法是：通过环的思想，进行交叉遍历，让两个指针都走完相同的路程。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (headA == <span class=\"keyword\">null</span> || headB == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        ListNode p = headA, q = headB;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != q) &#123;</span><br><span class=\"line\">            p = p == <span class=\"keyword\">null</span> ? headB : p.next;</span><br><span class=\"line\">            q = q == <span class=\"keyword\">null</span> ? headA : q.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Sort-List\"><a href=\"#Sort-List\" class=\"headerlink\" title=\"Sort List\"></a><a href=\"https://leetcode-cn.com/problems/sort-list/\" target=\"_blank\" rel=\"noopener\">Sort List</a></h3><p>思路：采用快慢指针查找到中间结点，进行递归的归并排序<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">sortList</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        ListNode pre = head, slow = head, fast = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (fast != <span class=\"keyword\">null</span> &amp;&amp; fast.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            pre = slow;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> merge(sortList(head), sortList(slow));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ListNode <span class=\"title\">merge</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l1 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l2 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class=\"line\">            l1.next = merge(l1.next, l2);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            l2.next = merge(l1, l2.next);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Delete-Node-in-a-Linked-List\"><a href=\"#Delete-Node-in-a-Linked-List\" class=\"headerlink\" title=\"Delete Node in a Linked List\"></a><a href=\"https://leetcode-cn.com/problems/delete-node-in-a-linked-list/\" target=\"_blank\" rel=\"noopener\">Delete Node in a Linked List</a></h3><p>思路：将要删除的结点的值设为下个结点的值，将下个结点删除。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteNode</span><span class=\"params\">(ListNode node)</span> </span>&#123;</span><br><span class=\"line\">        ListNode q = node.next;</span><br><span class=\"line\">        node.val = q.val;</span><br><span class=\"line\">        node.next = q.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h2><p>常用的解题方法</p>\n<blockquote>\n<ul>\n<li>运用哈希</li>\n<li>使用双指针</li>\n</ul>\n</blockquote>\n<h3 id=\"反转字符串-II\"><a href=\"#反转字符串-II\" class=\"headerlink\" title=\" 反转字符串 II\"></a><a href=\"https://leetcode-cn.com/problems/reverse-string-ii\" target=\"_blank\" rel=\"noopener\"> 反转字符串 II</a></h3><p>思路：每隔2k个字符开始遍历，然后进行反转。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">reverseStr</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.size(); i += <span class=\"number\">2</span> * k) &#123;</span><br><span class=\"line\">            reverse(s.begin() + i, min(s.begin() + i + k, s.end())); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Implement-strStr\"><a href=\"#Implement-strStr\" class=\"headerlink\" title=\"Implement strStr()\"></a><a href=\"https://leetcode-cn.com/problems/implement-strstr/\" target=\"_blank\" rel=\"noopener\">Implement strStr()</a></h3><p>思想：1.暴力破解，如果发生不匹配主串可能需要回溯。2.KMP算法。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">strStr</span><span class=\"params\">(String haystack, String needle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len1 = haystack.length(), len2 = needle.length();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; len1 &amp;&amp; j &lt; len2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (haystack.charAt(i) == needle.charAt(j)) &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                i = i - j + <span class=\"number\">1</span>;</span><br><span class=\"line\">                j = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j &gt;= len2) <span class=\"keyword\">return</span> i - j;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Valid-Anagram\"><a href=\"#Valid-Anagram\" class=\"headerlink\" title=\"Valid Anagram\"></a><a href=\"https://leetcode-cn.com/problems/valid-anagram/\" target=\"_blank\" rel=\"noopener\">Valid Anagram</a></h3><p>思想：创建一个哈希数组，如果两个字符串含有同样的单词则将该位置的值置为0。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAnagram</span><span class=\"params\">(String s, String t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length() != t.length()) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || t == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] map = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">256</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            map[s.charAt(i)]++;</span><br><span class=\"line\">            map[t.charAt(i)]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Integer i : map) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Valid-Palindrome\"><a href=\"#Valid-Palindrome\" class=\"headerlink\" title=\"Valid Palindrome\"></a><a href=\"https://leetcode-cn.com/problems/valid-palindrome/\" target=\"_blank\" rel=\"noopener\">Valid Palindrome</a></h3><p>思路：采用双指针的思想，在这当中，使用了java提供的一些函数。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.trim().isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = s.length() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt; r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Character.isLetterOrDigit(s.charAt(l))) &#123; <span class=\"comment\">//非字母或者数字的情况下。</span></span><br><span class=\"line\">                l++;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Character.isLetterOrDigit(s.charAt(r))) &#123;</span><br><span class=\"line\">                r--;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Character.toLowerCase(s.charAt(l)) == Character.toLowerCase(s.charAt(r))) &#123;</span><br><span class=\"line\">                l++;</span><br><span class=\"line\">                r--;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Array\"><a href=\"#Array\" class=\"headerlink\" title=\"Array\"></a>Array</h2><p>常用的解题方法</p>\n<blockquote>\n<ul>\n<li>遍历数组，标记变量</li>\n<li>双指针</li>\n</ul>\n</blockquote>\n<h3 id=\"PascalsTriangle\"><a href=\"#PascalsTriangle\" class=\"headerlink\" title=\"PascalsTriangle\"></a><a href=\"https://leetcode-cn.com/problems/pascals-triangle/\" target=\"_blank\" rel=\"noopener\">PascalsTriangle</a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (int i = 0; i &lt; numRows; i++) &#123;</span><br><span class=\"line\">            List&lt;Integer&gt; row = new ArrayList&lt;&gt;();</span><br><span class=\"line\">            for (int j = 0; j &lt;= i; j++) &#123;</span><br><span class=\"line\">                if (i == 0 || j == 0 || i == j) &#123;</span><br><span class=\"line\">                    row.add(1);</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    List&lt;Integer&gt; pre = res.get(i - 1);</span><br><span class=\"line\">                    row.add(pre.get(j - 1) + pre.get(j));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res.add(row);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Remove-Duplicates-from-Sorted-Array\"><a href=\"#Remove-Duplicates-from-Sorted-Array\" class=\"headerlink\" title=\"Remove Duplicates from Sorted Array\"></a><a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/\" target=\"_blank\" rel=\"noopener\">Remove Duplicates from Sorted Array</a></h3><p>思路：使用双指针，一个指针为遍历指针；另一个指针指向结果数组的每个位置，判断该位置要填充的元素。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">removeDuplicates</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] != nums[index]) &#123;</span><br><span class=\"line\">                nums[++index] = nums[i];<span class=\"comment\">//0号位置的值已经确定，从1号位置开始</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> index + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Remove-Duplicates-from-Sorted-Array-II\"><a href=\"#Remove-Duplicates-from-Sorted-Array-II\" class=\"headerlink\" title=\"Remove Duplicates from Sorted Array II\"></a><a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/\" target=\"_blank\" rel=\"noopener\">Remove Duplicates from Sorted Array II</a></h3><p>思路：同上题的思路相同，只是多一个变量count对元素的数量进行统计。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">removeDuplicates</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>, count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[index] == nums[i]) &#123;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (count &lt; <span class=\"number\">2</span>) nums[++index] = nums[i];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                count = <span class=\"number\">0</span>;</span><br><span class=\"line\">                nums[++index] = nums[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> index + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Remove-Element\"><a href=\"#Remove-Element\" class=\"headerlink\" title=\"Remove Element\"></a><a href=\"https://leetcode-cn.com/problems/remove-element/\" target=\"_blank\" rel=\"noopener\">Remove Element</a></h3><p>思路：双指针，在遍历时用另一个指针确定结果数组的每一个位置的最终值<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">removeElement</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] != val) &#123;</span><br><span class=\"line\">                nums[index++] = nums[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Majority-Element\"><a href=\"#Majority-Element\" class=\"headerlink\" title=\"Majority Element\"></a><a href=\"https://leetcode-cn.com/problems/majority-element/\" target=\"_blank\" rel=\"noopener\">Majority Element</a></h3><p>思路：设置变量majority存储可能是众数的元素，设置一个计数器count对元素的出现次数进行计数，在遍历数组的过程操作count变量进行一些操作。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> majority = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count == <span class=\"number\">0</span>) majority = nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (majority == nums[i]) count++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                count--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> majority;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Search-a-2D-Matrix\"><a href=\"#Search-a-2D-Matrix\" class=\"headerlink\" title=\"Search a 2D Matrix\"></a><a href=\"https://leetcode-cn.com/problems/search-a-2d-matrix/\" target=\"_blank\" rel=\"noopener\">Search a 2D Matrix</a></h3><p><a href=\"https://leetcode-cn.com/problems/search-a-2d-matrix-ii/\" target=\"_blank\" rel=\"noopener\">Search a 2D Matrix II</a><br>思路：根据题目的条件可知数组是有规律的，按照规律以某个元素所在行和列进行搜索，而减少对整个数组进行搜索。每个元素的行和列构成递增序列。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">searchMatrix</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] matrix, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rows = matrix.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rows == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cols = matrix[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = cols - <span class=\"number\">1</span>;  <span class=\"comment\">//右上角第一个元素的坐标</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; rows &amp;&amp; j &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (matrix[i][j] == target) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (matrix[i][j] &gt; target) &#123;</span><br><span class=\"line\">                j--;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Move-Zeroes\"><a href=\"#Move-Zeroes\" class=\"headerlink\" title=\"Move Zeroes\"></a><a href=\"https://leetcode-cn.com/problems/move-zeroes/\" target=\"_blank\" rel=\"noopener\">Move Zeroes</a></h3><p>思路：先将前面非零数字进行填充，将数组之后空的位置填充上零。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">moveZeroes</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                nums[index++] = nums[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            nums[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Intersection-of-Two-Arrays\"><a href=\"#Intersection-of-Two-Arrays\" class=\"headerlink\" title=\"Intersection of Two Arrays\"></a><a href=\"https://leetcode-cn.com/problems/intersection-of-two-arrays/\" target=\"_blank\" rel=\"noopener\">Intersection of Two Arrays</a></h3><p>思路：通过java提供的数据结构Set来帮助简化我们做题，用contains()方法啊，使得我们不用再去写遍历操作<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] intersection(<span class=\"keyword\">int</span>[] nums1, <span class=\"keyword\">int</span>[] nums2) &#123;</span><br><span class=\"line\">        Set&lt;Integer&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        Set&lt;Integer&gt; res = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n : nums1)</span><br><span class=\"line\">            set.add(n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n : nums2)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(set.contains(n))</span><br><span class=\"line\">                res.add(n);</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[res.size()];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span> ;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n : res)</span><br><span class=\"line\">            result[index++] = n;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Intersection-of-Two-Arrays-II\"><a href=\"#Intersection-of-Two-Arrays-II\" class=\"headerlink\" title=\"Intersection of Two Arrays II\"></a><a href=\"https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/\" target=\"_blank\" rel=\"noopener\">Intersection of Two Arrays II</a></h3><p>思路：设置一个hash数组统计数组当中每个元素出现的次数。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; intersect(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp;nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp;nums2) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; mp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums1.size(); i++) &#123;</span><br><span class=\"line\">            mp[nums1[i]]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums2.size(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mp[nums2[i]] &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                res.push_back(nums2[i]);</span><br><span class=\"line\">                mp[nums2[i]]--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Kth-Largest-Element-in-an-Array\"><a href=\"#Kth-Largest-Element-in-an-Array\" class=\"headerlink\" title=\"Kth Largest Element in an Array\"></a><a href=\"https://leetcode-cn.com/problems/kth-largest-element-in-an-array/\" target=\"_blank\" rel=\"noopener\">Kth Largest Element in an Array</a></h3><p>思路：先进行排序，再得出结果<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        Arrays.sort(nums);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[nums.length - k];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"stack\"><a href=\"#stack\" class=\"headerlink\" title=\"stack\"></a>stack</h2><p>需要掌握的思想</p>\n<blockquote>\n<ul>\n<li>模拟进出栈</li>\n<li>用栈解决问题的思想</li>\n</ul>\n</blockquote>\n<h3 id=\"Min-Stack\"><a href=\"#Min-Stack\" class=\"headerlink\" title=\"Min Stack\"></a><a href=\"https://leetcode-cn.com/problems/min-stack/submissions/\" target=\"_blank\" rel=\"noopener\">Min Stack</a></h3><p>思路：用两个栈，一个栈为最小值栈，一个栈为真实数据栈。或者用一个栈也可以。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MinStack</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * initialize your data structure here.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;Integer&gt; min, data; <span class=\"comment\">//min为最小值栈。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MinStack</span><span class=\"params\">()</span> </span>&#123;  <span class=\"comment\">//初始化两个栈</span></span><br><span class=\"line\">        min = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        data = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        data.push(x);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (min.empty() || min.peek() &gt;= x) &#123;</span><br><span class=\"line\">            min.push(x);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((<span class=\"keyword\">int</span>) data.peek() == (<span class=\"keyword\">int</span>) min.peek()) &#123; <span class=\"comment\">//通过peek()方法返回的为对象，两个不同的对象进行比较总是不相等的，所以需要进行强转。</span></span><br><span class=\"line\">            min.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        data.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">top</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getMin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> min.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Tree\"><a href=\"#Tree\" class=\"headerlink\" title=\"Tree\"></a>Tree</h2><h3 id=\"Binary-Tree-Preorder-Traversal\"><a href=\"#Binary-Tree-Preorder-Traversal\" class=\"headerlink\" title=\"Binary Tree Preorder Traversal\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-preorder-traversal/\" target=\"_blank\" rel=\"noopener\">Binary Tree Preorder Traversal</a></h3><p>思路：非递归遍历，根据访问的顺序：根-&gt;左-&gt;右。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root != <span class=\"keyword\">null</span>) stack.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack.empty()) &#123;</span><br><span class=\"line\">            TreeNode node = stack.pop();</span><br><span class=\"line\">            res.add(node.val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.right != <span class=\"keyword\">null</span>) stack.push(node.right);<span class=\"comment\">//将还没访问的结点入栈</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.left != <span class=\"keyword\">null</span>) stack.push(node.left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>递归写法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        list.add(root.val);</span><br><span class=\"line\">        preorderTraversal(root.left);</span><br><span class=\"line\">        preorderTraversal(root.right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Binary-Tree-Inorder-Traversal\"><a href=\"#Binary-Tree-Inorder-Traversal\" class=\"headerlink\" title=\"Binary Tree Inorder Traversal\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/\" target=\"_blank\" rel=\"noopener\">Binary Tree Inorder Traversal</a></h3><p>非递归写法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        TreeNode node = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack.empty() || node != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                stack.push(node);</span><br><span class=\"line\">                node = node.left;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                node = stack.pop();</span><br><span class=\"line\">                res.add(node.val);</span><br><span class=\"line\">                node = node.right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>递归写法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        inorderTraversal(root.left);</span><br><span class=\"line\">        list.add(root.val);</span><br><span class=\"line\">        inorderTraversal(root.right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Binary-Tree-Postorder-Traversal\"><a href=\"#Binary-Tree-Postorder-Traversal\" class=\"headerlink\" title=\"Binary Tree Postorder Traversal\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-postorder-traversal/\" target=\"_blank\" rel=\"noopener\">Binary Tree Postorder Traversal</a></h3><p>非递归写法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        TreeNode p = root, q = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span>) &#123;  <span class=\"comment\">//将左边的结点全部压入栈</span></span><br><span class=\"line\">                stack.push(p);</span><br><span class=\"line\">                p = p.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            q = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!stack.empty()) &#123;  <span class=\"comment\">//查看出栈结点的右结点是否为空</span></span><br><span class=\"line\">                p = stack.pop();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p.right == q) &#123;</span><br><span class=\"line\">                    res.add(p.val);</span><br><span class=\"line\">                    q = p;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    stack.push(p);</span><br><span class=\"line\">                    p = p.right; <span class=\"comment\">//转换成右边的结点</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (!stack.empty());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>递归写法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        postorderTraversal(root.left);</span><br><span class=\"line\">        postorderTraversal(root.right);</span><br><span class=\"line\">        list.add(root.val);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Kth-Smallest-Element-in-a-BST\"><a href=\"#Kth-Smallest-Element-in-a-BST\" class=\"headerlink\" title=\"Kth Smallest Element in a BST\"></a><a href=\"https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/\" target=\"_blank\" rel=\"noopener\">Kth Smallest Element in a BST</a></h3><p>思路：根据二叉搜索树的特性，选择用中序遍历的思想，设置变量统计当前访问到的结点，如果与所求结点k相等，则返回。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    TreeNode res;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">kthSmallest</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        InorderTraversal(root, k);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">InorderTraversal</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.left != <span class=\"keyword\">null</span>) InorderTraversal(root.left, k);</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count == k) &#123;</span><br><span class=\"line\">            res = root;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.right != <span class=\"keyword\">null</span>) InorderTraversal(root.right, k);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Lowest-Common-Ancestor-of-a-Binary-Tree\"><a href=\"#Lowest-Common-Ancestor-of-a-Binary-Tree\" class=\"headerlink\" title=\"Lowest Common Ancestor of a Binary Tree\"></a><a href=\"https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/\" target=\"_blank\" rel=\"noopener\">Lowest Common Ancestor of a Binary Tree</a></h3><p>递归时需要建立总体的观念<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span> || p == root || q == root) <span class=\"keyword\">return</span> root;  <span class=\"comment\">//当p和q当中有一个为根结点，则返回根结点</span></span><br><span class=\"line\">        TreeNode left = lowestCommonAncestor(root.left, p, q); <span class=\"comment\">//递归时需要建立全局的观念</span></span><br><span class=\"line\">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left!=<span class=\"keyword\">null</span>&amp;&amp;right!=<span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> root; <span class=\"comment\">//若p、q在分在左右子树之间，则返回根结点</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> left!=<span class=\"keyword\">null</span> ? left:right; <span class=\"comment\">//若p、q同在左子树或者右子树，则返回不为空的结点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Binary-Tree-Level-Order-Traversal\"><a href=\"#Binary-Tree-Level-Order-Traversal\" class=\"headerlink\" title=\"Binary Tree Level Order Traversal\"></a><a href>Binary Tree Level Order Traversal</a></h3><p>思路：使用深度优先遍历或者辅助队列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        dfs(root,0,res);</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void dfs(TreeNode root, int depth, List&lt;List&lt;Integer&gt;&gt; res) &#123;</span><br><span class=\"line\">        if (root != null) &#123;</span><br><span class=\"line\">            if (res.size() &lt; depth + 1) &#123;</span><br><span class=\"line\">                res.add(depth, new ArrayList&lt;Integer&gt;());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res.get(depth).add(root.val);</span><br><span class=\"line\">            depth++;</span><br><span class=\"line\">            if(root.left!=null) dfs(root.left,depth,res);</span><br><span class=\"line\">            if(root.right!=null) dfs(root.right,depth,res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Binary-Tree-Level-Order-Traversal-II\"><a href=\"#Binary-Tree-Level-Order-Traversal-II\" class=\"headerlink\" title=\"Binary Tree Level Order Traversal II\"></a><a href>Binary Tree Level Order Traversal II</a></h3><p>思路：和上一题的思路是一致的，只是在最后加入结果集时需要将其插入到头部。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class=\"line\">        LinkedList&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();</span><br><span class=\"line\">        if (root == null) return res;</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class=\"line\">        queue.offer(root);</span><br><span class=\"line\">        while (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">            for (int i = queue.size(); i &gt; 0; i--) &#123;</span><br><span class=\"line\">                TreeNode node = queue.poll();</span><br><span class=\"line\">                list.add(node.val);</span><br><span class=\"line\">                if (node.left != null) queue.offer(node.left);</span><br><span class=\"line\">                if (node.right != null) queue.offer(node.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res.offerFirst(list); //将其插入到链表的头部</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Average-of-Levels-in-Binary-Tree\"><a href=\"#Average-of-Levels-in-Binary-Tree\" class=\"headerlink\" title=\"Average of Levels in Binary Tree\"></a><a href>Average of Levels in Binary Tree</a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public List&lt;Double&gt; averageOfLevels(TreeNode root) &#123;</span><br><span class=\"line\">        List&lt;Double&gt; res = new LinkedList&lt;&gt;();</span><br><span class=\"line\">        if (root == null) return res;</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class=\"line\">        queue.add(root);</span><br><span class=\"line\">        while (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            int size = queue.size();</span><br><span class=\"line\">            double sum = 0;</span><br><span class=\"line\">            for (int i = size; i &gt; 0; i--) &#123;</span><br><span class=\"line\">                TreeNode node = queue.poll();</span><br><span class=\"line\">                if (node != null) sum += node.val;</span><br><span class=\"line\">                if (node.left != null) queue.add(node.left);</span><br><span class=\"line\">                if (node.right != null) queue.add(node.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res.add(sum / size);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"N-ary-Tree-Level-Order-Traversal\"><a href=\"#N-ary-Tree-Level-Order-Traversal\" class=\"headerlink\" title=\"N-ary Tree Level Order Traversal\"></a><a href>N-ary Tree Level Order Traversal</a></h3><p>递归算法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        dfs(root, 0, res);</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void dfs(Node root, int depth, List&lt;List&lt;Integer&gt;&gt; res) &#123;</span><br><span class=\"line\">        if (root != null) &#123;</span><br><span class=\"line\">            if (res.size() &lt; depth + 1) &#123;  //根据层数判断需要创建多少个的List</span><br><span class=\"line\">                res.add(depth, new ArrayList&lt;Integer&gt;());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res.get(depth).add(root.val);    //从特殊情况-&gt;一般情况</span><br><span class=\"line\">            depth++;</span><br><span class=\"line\">            for (Node child : root.children) &#123;</span><br><span class=\"line\">                dfs(child, depth, res);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>非递归算法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        if (root == null) return res;</span><br><span class=\"line\">        Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();</span><br><span class=\"line\">        queue.add(root);</span><br><span class=\"line\">        while (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">            for (int i = queue.size(); i &gt; 0; i--) &#123;  //一开始就必须获得队列的大小（队列是在不断变化的），队列当中当前层的全部结点</span><br><span class=\"line\">                Node node = queue.poll();</span><br><span class=\"line\">                list.add(node.val);</span><br><span class=\"line\">                for (Node child : node.children) &#123;</span><br><span class=\"line\">                    queue.add(child);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res.add(list);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Path-Sum\"><a href=\"#Path-Sum\" class=\"headerlink\" title=\"Path Sum \"></a><a href>Path Sum </a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public boolean hasPathSum(TreeNode root, int sum) &#123;</span><br><span class=\"line\">        if (root == null)</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        sum -= root.val;</span><br><span class=\"line\">        if (root.right == null &amp;&amp; root.left == null) return sum == 0; //判断最后根节点到叶子结点的路径和是否为零。</span><br><span class=\"line\">        return hasPathSum(root.left, sum) || hasPathSum(root.right, sum);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Path-Sum-II\"><a href=\"#Path-Sum-II\" class=\"headerlink\" title=\"Path Sum II\"></a><a href>Path Sum II</a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        helper(res,new ArrayList&lt;&gt;(),root,sum);</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void helper(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, TreeNode root, int sum) &#123;</span><br><span class=\"line\">        if (root == null) return;</span><br><span class=\"line\">        list.add(root.val);</span><br><span class=\"line\">        if (root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == sum) &#123;</span><br><span class=\"line\">            res.add(new ArrayList&lt;&gt;(list));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        helper(res,list,root.left,sum-root.val);</span><br><span class=\"line\">        helper(res,list,root.right,sum-root.val);</span><br><span class=\"line\">        list.remove(list.size()-1); //进行回溯。</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Path-Sum-III\"><a href=\"#Path-Sum-III\" class=\"headerlink\" title=\"Path Sum III\"></a><a href>Path Sum III</a></h3><p>思路：1.计算以某个结点为路径起始点的符合条件数。2.遍历所有的结点，并递归执行1步骤。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int pathSum(TreeNode* root, int sum) &#123; //遍历每个结点，每个结点都作为根计算路径</span><br><span class=\"line\">        if (root == NULL) return 0;</span><br><span class=\"line\">        return helper(root, sum) + pathSum(root -&gt; left, sum) + pathSum(root -&gt; right, sum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    int helper(TreeNode* root, int sum) &#123; //以root为根作为一条路径，计算该路径上符合条件的数目</span><br><span class=\"line\">        if (root == NULL) return 0;</span><br><span class=\"line\">        sum -= root -&gt; val; //sum为0的情况下即是符合路径</span><br><span class=\"line\">        return (sum == 0 ? 1 : 0) + helper(root -&gt; left, sum) + helper(root -&gt; right, sum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><h3 id=\"反转字符串\"><a href=\"#反转字符串\" class=\"headerlink\" title=\"反转字符串\"></a><a href=\"https://leetcode.com/problems/reverse-string/\" target=\"_blank\" rel=\"noopener\">反转字符串</a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public void reverseString(char[] s) &#123;</span><br><span class=\"line\">        swap(0, s.length - 1, s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void swap(int start, int end, char[] s) &#123;</span><br><span class=\"line\">        if (start &gt;= end) &#123;  //递归边界</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        char tmp = s[start];</span><br><span class=\"line\">        s[start] = s[end];</span><br><span class=\"line\">        s[end] = tmp;</span><br><span class=\"line\">        swap(start + 1, end - 1, s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"两两交换链表中的节点\"><a href=\"#两两交换链表中的节点\" class=\"headerlink\" title=\"两两交换链表中的节点\"></a><a href=\"https://leetcode-cn.com/problems/swap-nodes-in-pairs\" target=\"_blank\" rel=\"noopener\">两两交换链表中的节点</a></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">swapPairs</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) &#123;  <span class=\"comment\">//递归边界</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode next = head.next;  <span class=\"comment\">//递归体</span></span><br><span class=\"line\">        head.next = swapPairs(next.next);</span><br><span class=\"line\">        next.next = head;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","slug":"leetcode题解","excerpt":"","categories":[{"name":"Data Structure & Algorithm","slug":"Data-Structure-Algorithm","permalink":"http://yoursite.com/categories/Data-Structure-Algorithm/"}],"tags":[]}]}