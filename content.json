{"meta":{"title":"KANGPEIQIN","subtitle":null,"description":"The best preparation for tomorrow is doing your best today.","author":"KANGPEIQIN","url":"http://yoursite.com","root":"/"},"pages":[{},{}],"posts":[{"title":"数据结构与算法","date":"2020-01-15T15:15:00.000Z","path":"2020/01/15/回顾一下那些经典的算法/","text":"算法搜索广度优先遍历(BFS)算法概述:通过队列的协助，一层层访问路径相等的结点。 Shortest Path in Binary Matrix 12345678910111213141516171819202122232425262728293031class Solution &#123; public int shortestPathBinaryMatrix(int[][] grid) &#123; if (grid[0][0] == 1 || grid.length == 0) return -1;//左上角为障碍，返回-1 int[][] direction = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;-1, 1&#125;, &#123;1, 1&#125;, &#123;1, -1&#125;, &#123;-1, -1&#125;&#125;;//定义8个方向上下左右对角线,画个图会比较清晰 int step = 1, len = grid.length - 1; //定义最短路径 Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); //创建队列,队列当中存储结点在二维数组当中的坐标（x,y),用什么样的方式存储坐标？ queue.add(new int[]&#123;0, 0&#125;); //将当前左上角的结点入队 grid[0][0] = 1; while (!queue.isEmpty()) &#123; //如果队列不为空，将每一层的结点取出，并往队列当中添加新一层的结点 int size = queue.size(); //先取出每一层的结点的个数 for (int i = 0; i &lt; size; i++) &#123; int[] site = queue.poll();//访问每一个结点 int x = site[0], y = site[1]; if (x == len &amp;&amp; y == len) &#123; //如果遍历到最后右下角结点，结束返回 return step; &#125; for (int[] dir : direction) &#123; //尝试往每个方向前进 int nx = x + dir[0]; int ny = y + dir[1]; if (nx &lt; 0 || ny &lt; 0 || nx &gt; len || ny &gt; len || grid[nx][ny] == 1) &#123; continue; &#125; queue.add(new int[]&#123;nx, ny&#125;); grid[nx][ny] = 1; //入队时就要进行访问标记 &#125; &#125; step++; //遍历完一层，步数+1 &#125; return -1;//找不到结果 &#125; &#125; Perfect Squares 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int numSquares(int n) &#123; //反复减去平方序列 List&lt;Integer&gt; list = generateSquares(n);//产生平方序列 Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); //队列 boolean[] visit = new boolean[n + 1]; //标记访问数组 queue.add(n); visit[n] = true; int step = 0; while (!queue.isEmpty()) &#123; step++; int size = queue.size(); for (int i = 0; i &lt; size; i++) &#123; int node = queue.poll(); for (int square : list) &#123; int num = node - square; if (num &lt; 0) &#123; break; &#125; else if (num == 0) &#123; return step; &#125; else &#123; if (visit[num]) continue; queue.add(num); visit[num] = true; &#125; &#125; &#125; &#125; return step; &#125; private List&lt;Integer&gt; generateSquares(int n) &#123; //返回小于n的平方序列 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int k = 3, num = 1; while (num &lt;= n) &#123; list.add(num); num += k; k += 2; &#125; return list; &#125;&#125; 双指针 Two Sum II - Input array is sorted 12345678910111213141516class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; int start = 0, end = numbers.length - 1;//双指针 while (start &lt; end) &#123; int sum = numbers[start] + numbers[end]; if (sum &gt; target) &#123; end--; &#125; else if (sum == target) &#123; return new int[]&#123;start + 1, end + 1&#125;; &#125; else &#123; start++; &#125; &#125; return new int[2]; &#125;&#125; Sum of Square Numbers 12345678910111213141516class Solution &#123; public boolean judgeSquareSum(int c) &#123; int start = 0, end = (int) Math.sqrt(c); while (start &lt;= end) &#123; int squareSum = start * start + end * end; if (squareSum == c) &#123; return true; &#125; else if (squareSum &lt; c) &#123; start++; &#125; else &#123; end--; &#125; &#125; return false; &#125;&#125; 贪心算法 Assign Cookies 123456789101112131415161718/** * 贪心算法：每次操作都是局部最优，最后得到全局最优 */class Solution &#123; public int findContentChildren(int[] g, int[] s) &#123; if (g == null || s == null) return 0; int gi = 0, si = 0; Arrays.sort(g); Arrays.sort(s); while (gi &lt; g.length &amp;&amp; si &lt; s.length) &#123; if (g[gi] &lt;= s[si]) &#123; //尝试进行局部最优匹配 gi++; &#125; si++; &#125; return gi; &#125;&#125; 数据结构位运算 Hamming Distance 12345678910111213class Solution &#123; public int hammingDistance(int x, int y) &#123; int z = x ^ y;//如果在某个位置不同，表现为在该位置为1 int cnt = 0; while (z != 0) &#123; //判断1的个数 if ((z &amp; 1) == 1) &#123; cnt++; &#125; z = z &gt;&gt; 1; //左移一位 &#125; return cnt; &#125;&#125; Single Number 1234567class Solution &#123; public int singleNumber(int[] nums) &#123; int ret = 0; for (int n : nums) ret = ret ^ n; //利用 x^0=x 和 x^x=0 可得只出现一次的数字 return ret; &#125;&#125; Missing Number 123456789class Solution &#123; public int missingNumber(int[] nums) &#123; int ret = 0; for (int i = 0; i &lt; nums.length; i++) &#123; //数字的范围在[0~n-1]之间进行异或预算：利用 x^0=x 和 x^x=0 ret = ret ^ i ^ nums[i]; &#125; return ret ^ nums.length; //与n进行预算得出结果 &#125;&#125; 剑指offer题解 二维数组中的查找 1234567891011121314151617public class Solution &#123; public boolean Find(int target, int[][] array) &#123; if (array == null || array.length == 0 || array[0].length == 0) return false; int rows = array.length, cols = array[0].length; int r = 0, c = cols - 1; while (r &lt;= rows - 1 &amp;&amp; c &gt;= 0) &#123; //从右上角开始查找，减小搜索的范围 if (array[r][c] == target) &#123; return true; &#125; else if (target &gt; array[r][c]) &#123; r++; &#125; else &#123; c--; &#125; &#125; return false; &#125;&#125; 从尾到头打印链表 12345678910111213/** * 递归解法 */class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); if (listNode != null) &#123; ret.addAll(printListFromTailToHead(listNode.next)); ret.add(listNode.val); &#125; return ret; &#125;&#125; 替换空格 12345678910111213141516171819202122232425262728293031323334/** * 1、双指针解法 */class Solution &#123; public String replaceSpace(StringBuffer str) &#123; int p1 = str.length() - 1; for (int i = 0; i &lt;= p1; i++) &#123; if (str.charAt(i) == &apos; &apos;) &#123; str.append(&quot; &quot;); //有空格，往后添加两个空格用于存储%20 &#125; &#125; int p2 = str.length() - 1; while (p1 &gt;= 0 &amp;&amp; p1 &lt; p2) &#123; //使用双指针算法,从一个字符串的不同位置进行搜索 char c = str.charAt(p1--); if (c == &apos; &apos;) &#123; str.setCharAt(p2--, &apos;0&apos;); str.setCharAt(p2--, &apos;2&apos;); str.setCharAt(p2--, &apos;%&apos;); &#125; else &#123; str.setCharAt(p2--, c); &#125; &#125; return str.toString(); &#125;&#125;/** * 2、正则匹配 */class Solution &#123; public String replaceSpace(StringBuffer str) &#123; return str.toString().replaceAll(&quot; &quot;, &quot;%20&quot;); &#125;&#125;","raw":"title: 数据结构与算法\nauthor: KANGPEIQIN\ntags: []\ncategories:\n  - Data Structure & Algorithm\ndate: 2020-01-15 23:15:00\n---\n---\n<!--more-->\n# 算法\n## 搜索\n### 广度优先遍历(BFS)\n算法概述:通过队列的协助，一层层访问路径相等的结点。\n> 1091. Shortest Path in Binary Matrix\n\n```\nclass Solution {\n    public int shortestPathBinaryMatrix(int[][] grid) {\n        if (grid[0][0] == 1 || grid.length == 0) return -1;//左上角为障碍，返回-1\n        int[][] direction = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}, {-1, 1}, {1, 1}, {1, -1}, {-1, -1}};//定义8个方向上下左右对角线,画个图会比较清晰\n        int step = 1, len = grid.length - 1; //定义最短路径\n        Queue<int[]> queue = new LinkedList<>(); //创建队列,队列当中存储结点在二维数组当中的坐标（x,y),用什么样的方式存储坐标？\n        queue.add(new int[]{0, 0}); //将当前左上角的结点入队\n        grid[0][0] = 1;\n        while (!queue.isEmpty()) { //如果队列不为空，将每一层的结点取出，并往队列当中添加新一层的结点\n            int size = queue.size(); //先取出每一层的结点的个数\n            for (int i = 0; i < size; i++) {\n                int[] site = queue.poll();//访问每一个结点\n                int x = site[0], y = site[1];\n                if (x == len && y == len) { //如果遍历到最后右下角结点，结束返回\n                    return step;\n                }\n                for (int[] dir : direction) { //尝试往每个方向前进\n                    int nx = x + dir[0];\n                    int ny = y + dir[1];\n                    if (nx < 0 || ny < 0 || nx > len || ny > len || grid[nx][ny] == 1) {\n                        continue;\n                    }\n                    queue.add(new int[]{nx, ny});\n                    grid[nx][ny] = 1; //入队时就要进行访问标记\n                }\n            }\n            step++; //遍历完一层，步数+1\n        }\n        return -1;//找不到结果\n    }\n }\n```\n> 279. Perfect Squares\n\n```\nclass Solution {\n    public int numSquares(int n) { //反复减去平方序列\n        List<Integer> list = generateSquares(n);//产生平方序列\n        Queue<Integer> queue = new LinkedList<>(); //队列\n        boolean[] visit = new boolean[n + 1]; //标记访问数组\n        queue.add(n);\n        visit[n] = true;\n        int step = 0;\n        while (!queue.isEmpty()) {\n            step++;\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                int node = queue.poll();\n                for (int square : list) {\n                    int num = node - square;\n                    if (num < 0) {\n                        break;\n                    } else if (num == 0) {\n                        return step;\n                    } else {\n                        if (visit[num]) continue;\n                        queue.add(num);\n                        visit[num] = true;\n                    }\n                }\n            }\n        }\n        return step;\n    }\n\n    private List<Integer> generateSquares(int n) { //返回小于n的平方序列\n        List<Integer> list = new ArrayList<>();\n        int k = 3, num = 1;\n        while (num <= n) {\n            list.add(num);\n            num += k;\n            k += 2;\n        }\n        return list;\n    }\n}\n```\n## 双指针\n> 167. Two Sum II - Input array is sorted\n\n```\nclass Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        int start = 0, end = numbers.length - 1;//双指针\n        while (start < end) {\n            int sum = numbers[start] + numbers[end];\n            if (sum > target) {\n                end--;\n            } else if (sum == target) {\n                return new int[]{start + 1, end + 1};\n            } else {\n                start++;\n            }\n        }\n        return new int[2];\n    }\n}\n```\n> 633. Sum of Square Numbers\n\n```\nclass Solution {\n    public boolean judgeSquareSum(int c) {\n        int start = 0, end = (int) Math.sqrt(c);\n        while (start <= end) {\n            int squareSum = start * start + end * end;\n            if (squareSum == c) {\n                return true;\n            } else if (squareSum < c) {\n                start++;\n            } else {\n                end--;\n            }\n        }\n        return false;\n    }\n}\n\n```\n## 贪心算法\n> 455. Assign Cookies\n\n```\n/**\n * 贪心算法：每次操作都是局部最优，最后得到全局最优\n */\nclass Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        if (g == null || s == null) return 0;\n        int gi = 0, si = 0;\n        Arrays.sort(g);\n        Arrays.sort(s);\n        while (gi < g.length && si < s.length) {\n            if (g[gi] <= s[si]) { //尝试进行局部最优匹配\n                gi++;\n            }\n            si++;\n        }\n        return gi;\n    }\n}\n```\n# 数据结构\n## 位运算\n>461. Hamming Distance\n\n```\nclass Solution {\n    public int hammingDistance(int x, int y) {\n        int z = x ^ y;//如果在某个位置不同，表现为在该位置为1\n        int cnt = 0;\n        while (z != 0) { //判断1的个数\n            if ((z & 1) == 1) {\n                cnt++;\n            }\n            z = z >> 1; //左移一位\n        }\n        return cnt;\n    }\n}\n\n```\n> 136. Single Number\n\n```\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int ret = 0;\n        for (int n : nums) ret = ret ^ n; //利用 x^0=x 和 x^x=0 可得只出现一次的数字\n        return ret;\n    }\n}\n```\n> 268. Missing Number\n\n```\nclass Solution {\n    public int missingNumber(int[] nums) {\n        int ret = 0;\n        for (int i = 0; i < nums.length; i++) { //数字的范围在[0~n-1]之间进行异或预算：利用 x^0=x 和 x^x=0\n            ret = ret ^ i ^ nums[i];\n        }\n        return ret ^ nums.length; //与n进行预算得出结果\n    }\n}\n```\n# 剑指offer题解\n* 二维数组中的查找\n```\npublic class Solution {\n    public boolean Find(int target, int[][] array) {\n        if (array == null || array.length == 0 || array[0].length == 0) return false;\n        int rows = array.length, cols = array[0].length;\n        int r = 0, c = cols - 1;\n        while (r <= rows - 1 && c >= 0) { //从右上角开始查找，减小搜索的范围\n            if (array[r][c] == target) {\n                return true;\n            } else if (target > array[r][c]) {\n                r++;\n            } else {\n                c--;\n            }\n        }\n        return false;\n    }\n}\n```\n* 从尾到头打印链表\n```\n/**\n * 递归解法\n */\nclass Solution {\n    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {\n        ArrayList<Integer> ret = new ArrayList<>();\n        if (listNode != null) {\n            ret.addAll(printListFromTailToHead(listNode.next));\n            ret.add(listNode.val);\n        }\n        return ret;\n    }\n}\n```\n* 替换空格\n```\n/**\n * 1、双指针解法\n */\nclass Solution {\n    public String replaceSpace(StringBuffer str) {\n        int p1 = str.length() - 1;\n        for (int i = 0; i <= p1; i++) {\n            if (str.charAt(i) == ' ') {\n                str.append(\"  \"); //有空格，往后添加两个空格用于存储%20\n            }\n        }\n        int p2 = str.length() - 1;\n        while (p1 >= 0 && p1 < p2) { //使用双指针算法,从一个字符串的不同位置进行搜索\n            char c = str.charAt(p1--);\n            if (c == ' ') {\n                str.setCharAt(p2--, '0');\n                str.setCharAt(p2--, '2');\n                str.setCharAt(p2--, '%');\n            } else {\n                str.setCharAt(p2--, c);\n            }\n        }\n        return str.toString();\n    }\n}\n\n/**\n * 2、正则匹配\n */\nclass Solution {\n    public String replaceSpace(StringBuffer str) {\n        return str.toString().replaceAll(\" \", \"%20\");\n    }\n}\n```","content":"<hr>\n<a id=\"more\"></a>\n<h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><h2 id=\"搜索\"><a href=\"#搜索\" class=\"headerlink\" title=\"搜索\"></a>搜索</h2><h3 id=\"广度优先遍历-BFS\"><a href=\"#广度优先遍历-BFS\" class=\"headerlink\" title=\"广度优先遍历(BFS)\"></a>广度优先遍历(BFS)</h3><p>算法概述:通过队列的协助，一层层访问路径相等的结点。</p>\n<blockquote>\n<ol start=\"1091\">\n<li>Shortest Path in Binary Matrix</li>\n</ol>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int shortestPathBinaryMatrix(int[][] grid) &#123;</span><br><span class=\"line\">        if (grid[0][0] == 1 || grid.length == 0) return -1;//左上角为障碍，返回-1</span><br><span class=\"line\">        int[][] direction = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;-1, 1&#125;, &#123;1, 1&#125;, &#123;1, -1&#125;, &#123;-1, -1&#125;&#125;;//定义8个方向上下左右对角线,画个图会比较清晰</span><br><span class=\"line\">        int step = 1, len = grid.length - 1; //定义最短路径</span><br><span class=\"line\">        Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); //创建队列,队列当中存储结点在二维数组当中的坐标（x,y),用什么样的方式存储坐标？</span><br><span class=\"line\">        queue.add(new int[]&#123;0, 0&#125;); //将当前左上角的结点入队</span><br><span class=\"line\">        grid[0][0] = 1;</span><br><span class=\"line\">        while (!queue.isEmpty()) &#123; //如果队列不为空，将每一层的结点取出，并往队列当中添加新一层的结点</span><br><span class=\"line\">            int size = queue.size(); //先取出每一层的结点的个数</span><br><span class=\"line\">            for (int i = 0; i &lt; size; i++) &#123;</span><br><span class=\"line\">                int[] site = queue.poll();//访问每一个结点</span><br><span class=\"line\">                int x = site[0], y = site[1];</span><br><span class=\"line\">                if (x == len &amp;&amp; y == len) &#123; //如果遍历到最后右下角结点，结束返回</span><br><span class=\"line\">                    return step;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                for (int[] dir : direction) &#123; //尝试往每个方向前进</span><br><span class=\"line\">                    int nx = x + dir[0];</span><br><span class=\"line\">                    int ny = y + dir[1];</span><br><span class=\"line\">                    if (nx &lt; 0 || ny &lt; 0 || nx &gt; len || ny &gt; len || grid[nx][ny] == 1) &#123;</span><br><span class=\"line\">                        continue;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    queue.add(new int[]&#123;nx, ny&#125;);</span><br><span class=\"line\">                    grid[nx][ny] = 1; //入队时就要进行访问标记</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            step++; //遍历完一层，步数+1</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return -1;//找不到结果</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ol start=\"279\">\n<li>Perfect Squares</li>\n</ol>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int numSquares(int n) &#123; //反复减去平方序列</span><br><span class=\"line\">        List&lt;Integer&gt; list = generateSquares(n);//产生平方序列</span><br><span class=\"line\">        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); //队列</span><br><span class=\"line\">        boolean[] visit = new boolean[n + 1]; //标记访问数组</span><br><span class=\"line\">        queue.add(n);</span><br><span class=\"line\">        visit[n] = true;</span><br><span class=\"line\">        int step = 0;</span><br><span class=\"line\">        while (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            step++;</span><br><span class=\"line\">            int size = queue.size();</span><br><span class=\"line\">            for (int i = 0; i &lt; size; i++) &#123;</span><br><span class=\"line\">                int node = queue.poll();</span><br><span class=\"line\">                for (int square : list) &#123;</span><br><span class=\"line\">                    int num = node - square;</span><br><span class=\"line\">                    if (num &lt; 0) &#123;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    &#125; else if (num == 0) &#123;</span><br><span class=\"line\">                        return step;</span><br><span class=\"line\">                    &#125; else &#123;</span><br><span class=\"line\">                        if (visit[num]) continue;</span><br><span class=\"line\">                        queue.add(num);</span><br><span class=\"line\">                        visit[num] = true;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return step;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private List&lt;Integer&gt; generateSquares(int n) &#123; //返回小于n的平方序列</span><br><span class=\"line\">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        int k = 3, num = 1;</span><br><span class=\"line\">        while (num &lt;= n) &#123;</span><br><span class=\"line\">            list.add(num);</span><br><span class=\"line\">            num += k;</span><br><span class=\"line\">            k += 2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h2><blockquote>\n<ol start=\"167\">\n<li>Two Sum II - Input array is sorted</li>\n</ol>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int[] twoSum(int[] numbers, int target) &#123;</span><br><span class=\"line\">        int start = 0, end = numbers.length - 1;//双指针</span><br><span class=\"line\">        while (start &lt; end) &#123;</span><br><span class=\"line\">            int sum = numbers[start] + numbers[end];</span><br><span class=\"line\">            if (sum &gt; target) &#123;</span><br><span class=\"line\">                end--;</span><br><span class=\"line\">            &#125; else if (sum == target) &#123;</span><br><span class=\"line\">                return new int[]&#123;start + 1, end + 1&#125;;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                start++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return new int[2];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ol start=\"633\">\n<li>Sum of Square Numbers</li>\n</ol>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public boolean judgeSquareSum(int c) &#123;</span><br><span class=\"line\">        int start = 0, end = (int) Math.sqrt(c);</span><br><span class=\"line\">        while (start &lt;= end) &#123;</span><br><span class=\"line\">            int squareSum = start * start + end * end;</span><br><span class=\"line\">            if (squareSum == c) &#123;</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">            &#125; else if (squareSum &lt; c) &#123;</span><br><span class=\"line\">                start++;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                end--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h2><blockquote>\n<ol start=\"455\">\n<li>Assign Cookies</li>\n</ol>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 贪心算法：每次操作都是局部最优，最后得到全局最优</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int findContentChildren(int[] g, int[] s) &#123;</span><br><span class=\"line\">        if (g == null || s == null) return 0;</span><br><span class=\"line\">        int gi = 0, si = 0;</span><br><span class=\"line\">        Arrays.sort(g);</span><br><span class=\"line\">        Arrays.sort(s);</span><br><span class=\"line\">        while (gi &lt; g.length &amp;&amp; si &lt; s.length) &#123;</span><br><span class=\"line\">            if (g[gi] &lt;= s[si]) &#123; //尝试进行局部最优匹配</span><br><span class=\"line\">                gi++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            si++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return gi;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h1><h2 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h2><blockquote>\n<ol start=\"461\">\n<li>Hamming Distance</li>\n</ol>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int hammingDistance(int x, int y) &#123;</span><br><span class=\"line\">        int z = x ^ y;//如果在某个位置不同，表现为在该位置为1</span><br><span class=\"line\">        int cnt = 0;</span><br><span class=\"line\">        while (z != 0) &#123; //判断1的个数</span><br><span class=\"line\">            if ((z &amp; 1) == 1) &#123;</span><br><span class=\"line\">                cnt++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            z = z &gt;&gt; 1; //左移一位</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return cnt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ol start=\"136\">\n<li>Single Number</li>\n</ol>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int singleNumber(int[] nums) &#123;</span><br><span class=\"line\">        int ret = 0;</span><br><span class=\"line\">        for (int n : nums) ret = ret ^ n; //利用 x^0=x 和 x^x=0 可得只出现一次的数字</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ol start=\"268\">\n<li>Missing Number</li>\n</ol>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int missingNumber(int[] nums) &#123;</span><br><span class=\"line\">        int ret = 0;</span><br><span class=\"line\">        for (int i = 0; i &lt; nums.length; i++) &#123; //数字的范围在[0~n-1]之间进行异或预算：利用 x^0=x 和 x^x=0</span><br><span class=\"line\">            ret = ret ^ i ^ nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ret ^ nums.length; //与n进行预算得出结果</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"剑指offer题解\"><a href=\"#剑指offer题解\" class=\"headerlink\" title=\"剑指offer题解\"></a>剑指offer题解</h1><ul>\n<li><p>二维数组中的查找</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Solution &#123;</span><br><span class=\"line\">    public boolean Find(int target, int[][] array) &#123;</span><br><span class=\"line\">        if (array == null || array.length == 0 || array[0].length == 0) return false;</span><br><span class=\"line\">        int rows = array.length, cols = array[0].length;</span><br><span class=\"line\">        int r = 0, c = cols - 1;</span><br><span class=\"line\">        while (r &lt;= rows - 1 &amp;&amp; c &gt;= 0) &#123; //从右上角开始查找，减小搜索的范围</span><br><span class=\"line\">            if (array[r][c] == target) &#123;</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">            &#125; else if (target &gt; array[r][c]) &#123;</span><br><span class=\"line\">                r++;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                c--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>从尾到头打印链表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 递归解法</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class=\"line\">        ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        if (listNode != null) &#123;</span><br><span class=\"line\">            ret.addAll(printListFromTailToHead(listNode.next));</span><br><span class=\"line\">            ret.add(listNode.val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>替换空格</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 1、双指针解法</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public String replaceSpace(StringBuffer str) &#123;</span><br><span class=\"line\">        int p1 = str.length() - 1;</span><br><span class=\"line\">        for (int i = 0; i &lt;= p1; i++) &#123;</span><br><span class=\"line\">            if (str.charAt(i) == &apos; &apos;) &#123;</span><br><span class=\"line\">                str.append(&quot;  &quot;); //有空格，往后添加两个空格用于存储%20</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        int p2 = str.length() - 1;</span><br><span class=\"line\">        while (p1 &gt;= 0 &amp;&amp; p1 &lt; p2) &#123; //使用双指针算法,从一个字符串的不同位置进行搜索</span><br><span class=\"line\">            char c = str.charAt(p1--);</span><br><span class=\"line\">            if (c == &apos; &apos;) &#123;</span><br><span class=\"line\">                str.setCharAt(p2--, &apos;0&apos;);</span><br><span class=\"line\">                str.setCharAt(p2--, &apos;2&apos;);</span><br><span class=\"line\">                str.setCharAt(p2--, &apos;%&apos;);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                str.setCharAt(p2--, c);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return str.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 2、正则匹配</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public String replaceSpace(StringBuffer str) &#123;</span><br><span class=\"line\">        return str.toString().replaceAll(&quot; &quot;, &quot;%20&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n","slug":"回顾一下那些经典的算法","excerpt":"","categories":[{"name":"Data Structure & Algorithm","slug":"Data-Structure-Algorithm","permalink":"http://yoursite.com/categories/Data-Structure-Algorithm/"}],"tags":[]},{"title":"mysql常见问题小结","date":"2020-01-13T14:32:00.000Z","path":"2020/01/13/mysql常见问题小结/","text":"视图 视图是将查询结果当做一张虚表以提供复用或者简化sql操作 创建：create view viewname as &lt;query expression&gt; 删除: drop view viewname 替换视图：create or replace view 更新视图(不可更新:分组、联结、子查询、并、聚合函数) 查看创建语句：show create view viewname 作用：重用sql语句、简化(隐藏)复杂的sql操作、 保护数据(授予特定部分的访问权限而不是整表)、使用表的组成部分而不是整表 存储过程 定义：为了以后的使用而保存的一条或者多条的sql语句集合（比如:一个完整的操作需要多条语句才能完成） 作用：把处理进行封装、保证数据完整性(不需要反复建立一系列处理步骤)、简化变动管理 创建：1234CREATE PROCEDURE procedureName()BEGIN query expression;END 调用存储过程：CALL proceduName(parameter,@parameter) 用存储过程把结果返回给指定的变量out\\in声明变量：declare variable type将查询结果存入变量：into","raw":"title: mysql常见问题小结\nauthor: KANGPEIQIN\ntags: []\ncategories:\n  - DataBase\ndate: 2020-01-13 22:32:00\n---\n----\n<!--more-->\n## 视图\n> 视图是将查询结果当做一张虚表以提供复用或者简化sql操作\n>* 创建：`create view viewname as <query expression>`\n>* 删除: `drop view viewname`\n>* 替换视图：`create or replace view`\n>* 更新视图(不可更新:分组、联结、子查询、并、聚合函数)\n>* 查看创建语句：`show create view viewname`\n* 作用：`重用sql语句、简化(隐藏)复杂的sql操作、\n保护数据(授予特定部分的访问权限而不是整表)、使用表的组成部分而不是整表`\n\n## 存储过程\n> 定义：为了以后的使用而保存的一条或者多条的sql语句集合（比如:一个完整的操作需要多条语句才能完成）\n>* 作用：把处理进行封装、保证数据完整性(不需要反复建立一系列处理步骤)、简化变动管理\n>* 创建：\n```\nCREATE PROCEDURE procedureName()\nBEGIN\n    query expression;\nEND\n```\n调用存储过程：`CALL proceduName(parameter,@parameter)`\n* 用存储过程把结果返回给指定的变量`out\\in`声明变量：`declare variable type`将查询结果存入变量：`into`","content":"<hr>\n<a id=\"more\"></a>\n<h2 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h2><blockquote>\n<p>视图是将查询结果当做一张虚表以提供复用或者简化sql操作</p>\n<ul>\n<li>创建：<code>create view viewname as &lt;query expression&gt;</code></li>\n<li>删除: <code>drop view viewname</code></li>\n<li>替换视图：<code>create or replace view</code></li>\n<li>更新视图(不可更新:分组、联结、子查询、并、聚合函数)</li>\n<li>查看创建语句：<code>show create view viewname</code></li>\n<li>作用：<code>重用sql语句、简化(隐藏)复杂的sql操作、\n保护数据(授予特定部分的访问权限而不是整表)、使用表的组成部分而不是整表</code></li>\n</ul>\n</blockquote>\n<h2 id=\"存储过程\"><a href=\"#存储过程\" class=\"headerlink\" title=\"存储过程\"></a>存储过程</h2><blockquote>\n<p>定义：为了以后的使用而保存的一条或者多条的sql语句集合（比如:一个完整的操作需要多条语句才能完成）</p>\n<ul>\n<li>作用：把处理进行封装、保证数据完整性(不需要反复建立一系列处理步骤)、简化变动管理</li>\n<li>创建：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE PROCEDURE procedureName()</span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">    query expression;</span><br><span class=\"line\">END</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<p>调用存储过程：<code>CALL proceduName(parameter,@parameter)</code></p>\n<ul>\n<li>用存储过程把结果返回给指定的变量<code>out\\in</code>声明变量：<code>declare variable type</code>将查询结果存入变量：<code>into</code></li>\n</ul>\n","slug":"mysql常见问题小结","excerpt":"","categories":[{"name":"DataBase","slug":"DataBase","permalink":"http://yoursite.com/categories/DataBase/"}],"tags":[]},{"title":"2019年总结","date":"2019-12-31T14:50:00.000Z","path":"2019/12/31/2019年总结/","text":"总结2019年依旧是焦虑的一年，不知道未来的时间段是不是会持续这种迷茫。列了很多要做的事情，年末了才发现完成的情况不尽如意。归其原因，还是由于拖延症和决定心。常常是没做之前思绪万千，准备着手做的时候才发现无从下手。很长的一段时间，学习的时候既想着这个还没学，又想着那个也有缺漏，结果给一段时间内安排了很多任务。三心二意，最后的结果就是没办法专注。还有一些事情因为害怕做的不好而迟迟没有动手，想想真是遗憾。 不断的尝试不过，总的来说，还是取得了一些成就，比如有了很多第一次的尝试。第一次尝试搭建了自己的博客，写下第一篇技术博文；一次说走就走的旅程，去感受不一样的城市风景；开了自己的微信公众号。这对于自己来说都是前进路上的跨越的一小步。 要改进的地方 及时总结与输出，而不仅仅是输入，把握全局观。 及时抛出问题，而不是一直冥思苦想，提高效率。 多多与行业中的人进行交流，了解行业与技术的趋势。 克服拖延症，努力让优秀变成一种习惯。 有了想法就努力去实现，努力做到最好。","raw":"title: 2019年总结\nauthor: KANGPEIQIN\ntags: []\ncategories:\n  - 其他\ndate: 2019-12-31 22:50:00\n---\n![2020](/uploads/2020.jpg)\n<!--more-->\n### 总结\n2019年依旧是焦虑的一年，不知道未来的时间段是不是会持续这种迷茫。列了很多要做的事情，年末了才发现完成的情况不尽如意。归其原因，还是由于拖延症和决定心。常常是没做之前思绪万千，准备着手做的时候才发现无从下手。很长的一段时间，学习的时候既想着这个还没学，又想着那个也有缺漏，结果给一段时间内安排了很多任务。三心二意，最后的结果就是没办法专注。还有一些事情因为害怕做的不好而迟迟没有动手，想想真是遗憾。\n### 不断的尝试\n不过，总的来说，还是取得了一些成就，比如有了很多第一次的尝试。第一次尝试搭建了自己的博客，写下第一篇技术博文；一次说走就走的旅程，去感受不一样的城市风景；开了自己的微信公众号。这对于自己来说都是前进路上的跨越的一小步。\n### 要改进的地方\n>* 及时总结与输出，而不仅仅是输入，把握全局观。\n>* 及时抛出问题，而不是一直冥思苦想，提高效率。\n>* 多多与行业中的人进行交流，了解行业与技术的趋势。\n>* 克服拖延症，努力让优秀变成一种习惯。\n>* 有了想法就努力去实现，努力做到最好。\n\n\n","content":"<p><img src=\"/uploads/2020.jpg\" alt=\"2020\"><br><a id=\"more\"></a></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>2019年依旧是焦虑的一年，不知道未来的时间段是不是会持续这种迷茫。列了很多要做的事情，年末了才发现完成的情况不尽如意。归其原因，还是由于拖延症和决定心。常常是没做之前思绪万千，准备着手做的时候才发现无从下手。很长的一段时间，学习的时候既想着这个还没学，又想着那个也有缺漏，结果给一段时间内安排了很多任务。三心二意，最后的结果就是没办法专注。还有一些事情因为害怕做的不好而迟迟没有动手，想想真是遗憾。</p>\n<h3 id=\"不断的尝试\"><a href=\"#不断的尝试\" class=\"headerlink\" title=\"不断的尝试\"></a>不断的尝试</h3><p>不过，总的来说，还是取得了一些成就，比如有了很多第一次的尝试。第一次尝试搭建了自己的博客，写下第一篇技术博文；一次说走就走的旅程，去感受不一样的城市风景；开了自己的微信公众号。这对于自己来说都是前进路上的跨越的一小步。</p>\n<h3 id=\"要改进的地方\"><a href=\"#要改进的地方\" class=\"headerlink\" title=\"要改进的地方\"></a>要改进的地方</h3><blockquote>\n<ul>\n<li>及时总结与输出，而不仅仅是输入，把握全局观。</li>\n<li>及时抛出问题，而不是一直冥思苦想，提高效率。</li>\n<li>多多与行业中的人进行交流，了解行业与技术的趋势。</li>\n<li>克服拖延症，努力让优秀变成一种习惯。</li>\n<li>有了想法就努力去实现，努力做到最好。</li>\n</ul>\n</blockquote>\n","slug":"2019年总结","excerpt":"","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/其他/"}],"tags":[]},{"title":"Java基础知识小结","date":"2019-11-02T02:19:00.000Z","path":"2019/11/02/Java基础知识回顾/","text":"枚举类型概念理解 将有限集合创建为一种新的类型 创建 Color.java123enum Color &#123; RED, GREEN, WHITE&#125; 用反编译命令javap Color.class可得到：可见：enum类型本质还是一个类，查看Enum源码中并没有values()方法，该方法是编译器为我们所添加。我们可以这样Color red = color.RED直接返回类的对象引用。可以用构造函数对对实例进行初始化：123456789101112131415enum Color &#123; RED(\"this is red\"), GREEN, WHITE; private String description; private Color() &#123; &#125; private Color(String description) &#123; this.description = description; &#125; public String getDescription() &#123; return description; &#125;&#125; 常用方法：静态方法values()：Color[] colors = Color.values();返回enum实例的数组 | ordinal()：返回实例次序 | 由于java的单继承机制实现接口是使其子类化的唯一办法 java中脚本语言的使用 通过一个例子简单的总结一下java当中脚本语言的调用过程 12345678910111213141516171819202122232425262728293031323334353637383940import javax.script.Invocable;import javax.script.ScriptEngine;import javax.script.ScriptEngineFactory;import javax.script.ScriptEngineManager;import java.io.File;import java.io.PrintWriter;import java.io.StringWriter;import java.util.List;/** * 脚本语言的调用 */public class ScriptTest &#123; public static void main(String[] args) &#123; //1、获取脚本引擎 ScriptEngineManager manager = new ScriptEngineManager(); ScriptEngine engine = manager.getEngineByName(\"JavaScript\");//通过引擎名、MIME类型、扩展名获取引擎 List&lt;ScriptEngineFactory&gt; engineList = manager.getEngineFactories();//获取引擎工厂列表 for (ScriptEngineFactory scEngine : engineList) &#123; List&lt;String&gt; engineMimeTypes = scEngine.getMimeTypes();//获取引擎工厂所了解的名字、类型、扩展名 scEngine.getParameter(\"THREADING\");//并发执行脚本是否安全 &#125; //2、脚本的调用,直接调用、或者通过外部输入 try &#123; StringWriter writer = new StringWriter(); engine.getContext().setWriter(new PrintWriter(writer, true));//重定向脚本的输入和输出，print函数产生的输出会被发送到writer，默认向屏幕输出结果 engine.eval(\"function calculate(param)&#123;var n=3;return n*param&#125;\"); //执行脚本 System.out.println(engine.eval(\"calculate(3) + 1\").toString()); File file = new File(\"test.txt\"); engine.put(\"f\", file); //对象作为全局变量暴露于脚本中,可在脚本中使用对象以及对象的成员与方法 engine.eval(\"print(f.getAbsolutePath())\");//流向writer engine.eval(\"function greet(x)&#123;return x&#125;\"); Greeter g = ((Invocable) engine).getInterface(Greeter.class); //匹配相应的java接口，访问脚本 String result = g.greet(\"world\"); System.out.println(result); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 123public interface Greeter &#123; String greet(String greeting);&#125; 序列化 利用序列化进行深拷贝：拷贝一个对象及其引用，防止操作同一个内存对象（代码来源:core java）1234567891011121314151617class SerialClonable implements Cloneable, Serializable &#123; public Object clone() &#123; try &#123; ByteArrayOutputStream bout = new ByteArrayOutputStream(); ObjectOutputStream out = new ObjectOutputStream(bout); out.writeObject(this); out.close(); ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray()); ObjectInputStream in = new ObjectInputStream(bin); Object ret = in.readObject(); in.close(); return ret; &#125; catch (Exception e) &#123; return null; &#125; &#125;&#125; 类加载器 类加载器是将字节码加载到JVM当中，系统提供了一些类加载器，我们也可以根据需求实现自己的类加载器：只要继承ClassLoader类并重写findClass方法。以下通过示例代码展示，更多原理可以参考IBM Developer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * 加载被加密的字节码（加载过程中进行解密） */public class LoaderTest &#123; public static void main(String[] args) throws IOException &#123; String curDir = System.getProperty(&quot;user.dir&quot;); //当前用户目录 String source = curDir + File.separator + &quot;src&quot; + File.separator + &quot;Test.java&quot;;//需要进行编译的源文件 String classFile = curDir + File.separator + &quot;src&quot; + File.separator + &quot;Test.class&quot;;//要进行加密处理的class文件 String out = curDir + File.separator + &quot;src&quot; + File.separator + &quot;Test&quot;; //加密后的class文件 JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); int result = compiler.run(null, null, null, source);//用API编译源代码，在目录下生成Class文件 ProcessClassByte processClassByte = new ProcessClassByte(); processClassByte.cryptClass(classFile, out, 3);//加密Test.class文件 try &#123; ClassLoader loader = new CryptLoader(3);//用自定义的类加载器 Class&lt;?&gt; c = loader.loadClass(out); //加载指定类,如果指定类不符合要求则加载会报错 Method m = c.getMethod(&quot;main&quot;, String[].class); m.invoke(null, (Object) new String[]&#123;&#125;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class CryptLoader extends ClassLoader &#123; private int key; public CryptLoader(int key) &#123; this.key = key; &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; //查找类的字节码 byte[] classBytes = null; try &#123; ProcessClassByte processClassByte = new ProcessClassByte(); classBytes = processClassByte.loadClassByBytes(name, key); &#125; catch (Exception e) &#123; throw new ClassNotFoundException(name); &#125; Class&lt;?&gt; cl = defineClass(null, classBytes, 0, classBytes.length);//将新的类添加到虚拟机中 if (cl == null) throw new ClassNotFoundException(name); return cl; &#125;&#125;class ProcessClassByte &#123; public void cryptClass(String fileIn, String fileOut, int key) &#123; //加密class文件 try &#123; FileInputStream in = new FileInputStream(fileIn); FileOutputStream out = new FileOutputStream(fileOut); int ch; while ((ch = in.read()) != -1) &#123; //读入一字节，对该字节进行处理，并写到文件输出流中 byte c = (byte) (ch + key); out.write(c); &#125; in.close(); out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public byte[] loadClassByBytes(String name, int key) throws IOException &#123; //返回解密后的class文件字节数组 FileInputStream in = new FileInputStream(name); try &#123; ByteArrayOutputStream buffer = new ByteArrayOutputStream(); int ch; while ((ch = in.read()) != -1) &#123; byte b = (byte) (ch - key); buffer.write(b); &#125; in.close(); return buffer.toByteArray(); &#125; finally &#123; in.close(); &#125; &#125;&#125; 参考：《Thinking In Java(4th edition)、《core java》","raw":"title: Java基础知识小结\nauthor: KANGPEIQIN\ntags: []\ncategories:\n  - Java\ndate: 2019-11-02 10:19:00\n---\n---\n<!--more-->\n## 枚举类型\n概念理解 \n> 将有限集合创建为一种新的类型\n\n创建 `Color.java` \n```java\nenum Color {\n    RED, GREEN, WHITE\n}\n```\n用反编译命令`javap Color.class`可得到：\n![反编译后的类](/uploads/enum.png)可见：enum类型本质还是一个类，查看Enum源码中并没有values()方法，该方法是编译器为我们所添加。我们可以这样`Color red = color.RED`直接返回类的对象引用。可以用构造函数对对实例进行初始化：\n```java\nenum Color {\n    RED(\"this is red\"), GREEN, WHITE;\n    private String description;\n\n    private Color() {\n    }\n\n    private Color(String description) {\n        this.description = description;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n}\n```\n**常用方法**：静态方法`values()`：`Color[] colors = Color.values();`返回enum实例的数组 | `ordinal()`：返回实例次序 | 由于java的单继承机制实现接口是使其子类化的唯一办法\n\n## java中脚本语言的使用\n> 通过一个例子简单的总结一下java当中脚本语言的调用过程\n\n```java\nimport javax.script.Invocable;\nimport javax.script.ScriptEngine;\nimport javax.script.ScriptEngineFactory;\nimport javax.script.ScriptEngineManager;\nimport java.io.File;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.util.List;\n\n/**\n * 脚本语言的调用\n */\npublic class ScriptTest {\n    public static void main(String[] args) {\n        //1、获取脚本引擎\n        ScriptEngineManager manager = new ScriptEngineManager();\n        ScriptEngine engine = manager.getEngineByName(\"JavaScript\");//通过引擎名、MIME类型、扩展名获取引擎\n        List<ScriptEngineFactory> engineList = manager.getEngineFactories();//获取引擎工厂列表\n        for (ScriptEngineFactory scEngine : engineList) {\n            List<String> engineMimeTypes = scEngine.getMimeTypes();//获取引擎工厂所了解的名字、类型、扩展名\n            scEngine.getParameter(\"THREADING\");//并发执行脚本是否安全\n        }\n        //2、脚本的调用,直接调用、或者通过外部输入\n        try {\n            StringWriter writer = new StringWriter();\n            engine.getContext().setWriter(new PrintWriter(writer, true));//重定向脚本的输入和输出，print函数产生的输出会被发送到writer，默认向屏幕输出结果\n            engine.eval(\"function calculate(param){var n=3;return n*param}\"); //执行脚本\n            System.out.println(engine.eval(\"calculate(3) + 1\").toString());\n            File file = new File(\"test.txt\");\n            engine.put(\"f\", file); //对象作为全局变量暴露于脚本中,可在脚本中使用对象以及对象的成员与方法\n            engine.eval(\"print(f.getAbsolutePath())\");//流向writer\n            engine.eval(\"function greet(x){return x}\");\n            Greeter g = ((Invocable) engine).getInterface(Greeter.class); //匹配相应的java接口，访问脚本\n            String result = g.greet(\"world\");\n            System.out.println(result);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n```java\npublic interface Greeter {\n    String greet(String greeting);\n}\n```\n## 序列化\n* 利用序列化进行深拷贝：拷贝一个对象及其引用，防止操作同一个内存对象（代码来源:core java）\n```\nclass SerialClonable implements Cloneable, Serializable {\n    public Object clone() {\n        try {\n            ByteArrayOutputStream bout = new ByteArrayOutputStream();\n            ObjectOutputStream out = new ObjectOutputStream(bout);\n            out.writeObject(this);\n            out.close();\n            ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray());\n            ObjectInputStream in = new ObjectInputStream(bin);\n            Object ret = in.readObject();\n            in.close();\n            return ret;\n        } catch (Exception e) {\n            return null;\n        }\n    }\n} \n```\n## 类加载器\n* 类加载器是将字节码加载到JVM当中，系统提供了一些类加载器，我们也可以根据需求实现自己的类加载器：只要继承`ClassLoader类`并重写`findClass方法`。以下通过示例代码展示，更多原理可以参考[IBM Developer](https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html#code3)\n\n```\n/**\n * 加载被加密的字节码（加载过程中进行解密）\n */\npublic class LoaderTest {\n    public static void main(String[] args) throws IOException {\n        String curDir = System.getProperty(\"user.dir\"); //当前用户目录\n        String source = curDir + File.separator + \"src\" + File.separator + \"Test.java\";//需要进行编译的源文件\n        String classFile = curDir + File.separator + \"src\" + File.separator + \"Test.class\";//要进行加密处理的class文件\n        String out = curDir + File.separator + \"src\" + File.separator + \"Test\"; //加密后的class文件\n        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n        int result = compiler.run(null, null, null, source);//用API编译源代码，在目录下生成Class文件\n        ProcessClassByte processClassByte = new ProcessClassByte();\n        processClassByte.cryptClass(classFile, out, 3);//加密Test.class文件\n        try {\n            ClassLoader loader = new CryptLoader(3);//用自定义的类加载器\n            Class<?> c = loader.loadClass(out); //加载指定类,如果指定类不符合要求则加载会报错\n            Method m = c.getMethod(\"main\", String[].class);\n            m.invoke(null, (Object) new String[]{});\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass CryptLoader extends ClassLoader {\n    private int key;\n\n    public CryptLoader(int key) {\n        this.key = key;\n    }\n\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException { //查找类的字节码\n        byte[] classBytes = null;\n        try {\n            ProcessClassByte processClassByte = new ProcessClassByte();\n            classBytes = processClassByte.loadClassByBytes(name, key);\n        } catch (Exception e) {\n            throw new ClassNotFoundException(name);\n        }\n        Class<?> cl = defineClass(null, classBytes, 0, classBytes.length);//将新的类添加到虚拟机中\n        if (cl == null) throw new ClassNotFoundException(name);\n        return cl;\n    }\n}\n\nclass ProcessClassByte {\n    public void cryptClass(String fileIn, String fileOut, int key) { //加密class文件\n        try {\n            FileInputStream in = new FileInputStream(fileIn);\n            FileOutputStream out = new FileOutputStream(fileOut);\n            int ch;\n            while ((ch = in.read()) != -1) { //读入一字节，对该字节进行处理，并写到文件输出流中\n                byte c = (byte) (ch + key);\n                out.write(c);\n            }\n            in.close();\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public byte[] loadClassByBytes(String name, int key) throws IOException { //返回解密后的class文件字节数组\n        FileInputStream in = new FileInputStream(name);\n        try {\n            ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n            int ch;\n            while ((ch = in.read()) != -1) {\n                byte b = (byte) (ch - key);\n                buffer.write(b);\n            }\n            in.close();\n            return buffer.toByteArray();\n        } finally {\n            in.close();\n        }\n    }\n}\n```\n\n---\n> 参考：《Thinking In Java(4th edition)、《core java》","content":"<hr>\n<a id=\"more\"></a>\n<h2 id=\"枚举类型\"><a href=\"#枚举类型\" class=\"headerlink\" title=\"枚举类型\"></a>枚举类型</h2><p>概念理解 </p>\n<blockquote>\n<p>将有限集合创建为一种新的类型</p>\n</blockquote>\n<p>创建 <code>Color.java</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;</span><br><span class=\"line\">    RED, GREEN, WHITE</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>用反编译命令<code>javap Color.class</code>可得到：<br><img src=\"/uploads/enum.png\" alt=\"反编译后的类\">可见：enum类型本质还是一个类，查看Enum源码中并没有values()方法，该方法是编译器为我们所添加。我们可以这样<code>Color red = color.RED</code>直接返回类的对象引用。可以用构造函数对对实例进行初始化：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;</span><br><span class=\"line\">    RED(<span class=\"string\">\"this is red\"</span>), GREEN, WHITE;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String description;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Color</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Color</span><span class=\"params\">(String description)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.description = description;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getDescription</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> description;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>常用方法</strong>：静态方法<code>values()</code>：<code>Color[] colors = Color.values();</code>返回enum实例的数组 | <code>ordinal()</code>：返回实例次序 | 由于java的单继承机制实现接口是使其子类化的唯一办法</p>\n<h2 id=\"java中脚本语言的使用\"><a href=\"#java中脚本语言的使用\" class=\"headerlink\" title=\"java中脚本语言的使用\"></a>java中脚本语言的使用</h2><blockquote>\n<p>通过一个例子简单的总结一下java当中脚本语言的调用过程</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> javax.script.Invocable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.script.ScriptEngine;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.script.ScriptEngineFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.script.ScriptEngineManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.PrintWriter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.StringWriter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 脚本语言的调用</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScriptTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//1、获取脚本引擎</span></span><br><span class=\"line\">        ScriptEngineManager manager = <span class=\"keyword\">new</span> ScriptEngineManager();</span><br><span class=\"line\">        ScriptEngine engine = manager.getEngineByName(<span class=\"string\">\"JavaScript\"</span>);<span class=\"comment\">//通过引擎名、MIME类型、扩展名获取引擎</span></span><br><span class=\"line\">        List&lt;ScriptEngineFactory&gt; engineList = manager.getEngineFactories();<span class=\"comment\">//获取引擎工厂列表</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (ScriptEngineFactory scEngine : engineList) &#123;</span><br><span class=\"line\">            List&lt;String&gt; engineMimeTypes = scEngine.getMimeTypes();<span class=\"comment\">//获取引擎工厂所了解的名字、类型、扩展名</span></span><br><span class=\"line\">            scEngine.getParameter(<span class=\"string\">\"THREADING\"</span>);<span class=\"comment\">//并发执行脚本是否安全</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//2、脚本的调用,直接调用、或者通过外部输入</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            StringWriter writer = <span class=\"keyword\">new</span> StringWriter();</span><br><span class=\"line\">            engine.getContext().setWriter(<span class=\"keyword\">new</span> PrintWriter(writer, <span class=\"keyword\">true</span>));<span class=\"comment\">//重定向脚本的输入和输出，print函数产生的输出会被发送到writer，默认向屏幕输出结果</span></span><br><span class=\"line\">            engine.eval(<span class=\"string\">\"function calculate(param)&#123;var n=3;return n*param&#125;\"</span>); <span class=\"comment\">//执行脚本</span></span><br><span class=\"line\">            System.out.println(engine.eval(<span class=\"string\">\"calculate(3) + 1\"</span>).toString());</span><br><span class=\"line\">            File file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"test.txt\"</span>);</span><br><span class=\"line\">            engine.put(<span class=\"string\">\"f\"</span>, file); <span class=\"comment\">//对象作为全局变量暴露于脚本中,可在脚本中使用对象以及对象的成员与方法</span></span><br><span class=\"line\">            engine.eval(<span class=\"string\">\"print(f.getAbsolutePath())\"</span>);<span class=\"comment\">//流向writer</span></span><br><span class=\"line\">            engine.eval(<span class=\"string\">\"function greet(x)&#123;return x&#125;\"</span>);</span><br><span class=\"line\">            Greeter g = ((Invocable) engine).getInterface(Greeter.class); <span class=\"comment\">//匹配相应的java接口，访问脚本</span></span><br><span class=\"line\">            String result = g.greet(<span class=\"string\">\"world\"</span>);</span><br><span class=\"line\">            System.out.println(result);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Greeter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">greet</span><span class=\"params\">(String greeting)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"序列化\"><a href=\"#序列化\" class=\"headerlink\" title=\"序列化\"></a>序列化</h2><ul>\n<li>利用序列化进行深拷贝：拷贝一个对象及其引用，防止操作同一个内存对象（代码来源:core java）<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class SerialClonable implements Cloneable, Serializable &#123;</span><br><span class=\"line\">    public Object clone() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            ByteArrayOutputStream bout = new ByteArrayOutputStream();</span><br><span class=\"line\">            ObjectOutputStream out = new ObjectOutputStream(bout);</span><br><span class=\"line\">            out.writeObject(this);</span><br><span class=\"line\">            out.close();</span><br><span class=\"line\">            ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray());</span><br><span class=\"line\">            ObjectInputStream in = new ObjectInputStream(bin);</span><br><span class=\"line\">            Object ret = in.readObject();</span><br><span class=\"line\">            in.close();</span><br><span class=\"line\">            return ret;</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h2><ul>\n<li>类加载器是将字节码加载到JVM当中，系统提供了一些类加载器，我们也可以根据需求实现自己的类加载器：只要继承<code>ClassLoader类</code>并重写<code>findClass方法</code>。以下通过示例代码展示，更多原理可以参考<a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html#code3\" target=\"_blank\" rel=\"noopener\">IBM Developer</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 加载被加密的字节码（加载过程中进行解密）</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class LoaderTest &#123;</span><br><span class=\"line\">    public static void main(String[] args) throws IOException &#123;</span><br><span class=\"line\">        String curDir = System.getProperty(&quot;user.dir&quot;); //当前用户目录</span><br><span class=\"line\">        String source = curDir + File.separator + &quot;src&quot; + File.separator + &quot;Test.java&quot;;//需要进行编译的源文件</span><br><span class=\"line\">        String classFile = curDir + File.separator + &quot;src&quot; + File.separator + &quot;Test.class&quot;;//要进行加密处理的class文件</span><br><span class=\"line\">        String out = curDir + File.separator + &quot;src&quot; + File.separator + &quot;Test&quot;; //加密后的class文件</span><br><span class=\"line\">        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();</span><br><span class=\"line\">        int result = compiler.run(null, null, null, source);//用API编译源代码，在目录下生成Class文件</span><br><span class=\"line\">        ProcessClassByte processClassByte = new ProcessClassByte();</span><br><span class=\"line\">        processClassByte.cryptClass(classFile, out, 3);//加密Test.class文件</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            ClassLoader loader = new CryptLoader(3);//用自定义的类加载器</span><br><span class=\"line\">            Class&lt;?&gt; c = loader.loadClass(out); //加载指定类,如果指定类不符合要求则加载会报错</span><br><span class=\"line\">            Method m = c.getMethod(&quot;main&quot;, String[].class);</span><br><span class=\"line\">            m.invoke(null, (Object) new String[]&#123;&#125;);</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class CryptLoader extends ClassLoader &#123;</span><br><span class=\"line\">    private int key;</span><br><span class=\"line\"></span><br><span class=\"line\">    public CryptLoader(int key) &#123;</span><br><span class=\"line\">        this.key = key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; //查找类的字节码</span><br><span class=\"line\">        byte[] classBytes = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            ProcessClassByte processClassByte = new ProcessClassByte();</span><br><span class=\"line\">            classBytes = processClassByte.loadClassByBytes(name, key);</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            throw new ClassNotFoundException(name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Class&lt;?&gt; cl = defineClass(null, classBytes, 0, classBytes.length);//将新的类添加到虚拟机中</span><br><span class=\"line\">        if (cl == null) throw new ClassNotFoundException(name);</span><br><span class=\"line\">        return cl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class ProcessClassByte &#123;</span><br><span class=\"line\">    public void cryptClass(String fileIn, String fileOut, int key) &#123; //加密class文件</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            FileInputStream in = new FileInputStream(fileIn);</span><br><span class=\"line\">            FileOutputStream out = new FileOutputStream(fileOut);</span><br><span class=\"line\">            int ch;</span><br><span class=\"line\">            while ((ch = in.read()) != -1) &#123; //读入一字节，对该字节进行处理，并写到文件输出流中</span><br><span class=\"line\">                byte c = (byte) (ch + key);</span><br><span class=\"line\">                out.write(c);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            in.close();</span><br><span class=\"line\">            out.close();</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public byte[] loadClassByBytes(String name, int key) throws IOException &#123; //返回解密后的class文件字节数组</span><br><span class=\"line\">        FileInputStream in = new FileInputStream(name);</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            ByteArrayOutputStream buffer = new ByteArrayOutputStream();</span><br><span class=\"line\">            int ch;</span><br><span class=\"line\">            while ((ch = in.read()) != -1) &#123;</span><br><span class=\"line\">                byte b = (byte) (ch - key);</span><br><span class=\"line\">                buffer.write(b);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            in.close();</span><br><span class=\"line\">            return buffer.toByteArray();</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            in.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<blockquote>\n<p>参考：《Thinking In Java(4th edition)、《core java》</p>\n</blockquote>\n","slug":"Java基础知识回顾","excerpt":"","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"PAT题解","date":"2019-07-22T14:45:46.000Z","path":"2019/07/22/pat/","text":"树与二叉树1020 Tree Traversals12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int MAXN=50; //最大的结点数 int n;int post[MAXN],in[MAXN];//用于保存后序和中序遍历结点的数组/*定义树结点结构*/struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right;&#125;;/*根据中序和后续递归创建树*/TreeNode *createTree(int postL,int postR,int inL,int inR) &#123; if(postL &gt; postR) &#123; //递归边界 return NULL; &#125; TreeNode *root = new TreeNode();//创建根结点 root-&gt;val = post[postR]; int k=0; for(k = 0; k &lt; n; k++) &#123; //计算出根结点在中序序列的位置 if(in[k]==post[postR]) &#123; break; &#125; &#125; int numberLeft = k-inL; //左子树的结点数 3 root-&gt;left = createTree(postL,postL+numberLeft-1,inL,inL+numberLeft-1); //下标是从0开始的 root-&gt;right = createTree(postL+numberLeft,postR-1,inL+numberLeft+1,inR); return root; &#125;/* 层序遍历 */void levelTraver(TreeNode* root)&#123; int count = 0; queue&lt;TreeNode*&gt; q;//创建一个队列 q.push(root); while(!q.empty())&#123; TreeNode* node = q.front(); //取出队列首结点 q.pop(); //弹出首结点 printf(&quot;%d&quot;,node-&gt;val); count++; if(count&lt;n) printf(&quot; &quot;); if(node-&gt;left)&#123; q.push(node-&gt;left); &#125; if(node-&gt;right)&#123; q.push(node-&gt;right); &#125; &#125; &#125; int main() &#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf(&quot;%d&quot;,&amp;post[i]); &#125; for(int i=0;i&lt;n;i++)&#123; scanf(&quot;%d&quot;,&amp;in[i]); &#125; TreeNode* root = createTree(0,n-1,0,n-1); levelTraver(root); return 0;&#125;","raw":"title: PAT题解\ncategories: Data Structure & Algorithm\ndate: 2019-07-22 22:45:46\n---\n---\n<!--more-->\n### 树与二叉树\n#### 1020 Tree Traversals\n```\n#include<cstdio>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nconst int MAXN=50; //最大的结点数 \nint n;\nint post[MAXN],in[MAXN];//用于保存后序和中序遍历结点的数组\n/*定义树结点结构*/\nstruct TreeNode {\n\tint val;\n\tstruct TreeNode *left;\n\tstruct TreeNode *right;\n};\n/*根据中序和后续递归创建树*/\nTreeNode *createTree(int postL,int postR,int inL,int inR) {\n\tif(postL > postR) { //递归边界\n\t\treturn NULL;\n\t}\n\tTreeNode *root = new TreeNode();//创建根结点\n\troot->val = post[postR];\n\tint k=0;\n\tfor(k = 0; k < n; k++) { //计算出根结点在中序序列的位置\n\t\tif(in[k]==post[postR]) {\n\t\t\tbreak;                \n\t\t}\n\t}\n\tint numberLeft = k-inL; //左子树的结点数 3\n\troot->left = createTree(postL,postL+numberLeft-1,inL,inL+numberLeft-1); //下标是从0开始的 \n\troot->right = createTree(postL+numberLeft,postR-1,inL+numberLeft+1,inR);\n\treturn root; \n}\n\n/* 层序遍历 */\nvoid levelTraver(TreeNode* root){\n\tint count = 0;\n\tqueue<TreeNode*> q;//创建一个队列 \n\tq.push(root);\n\twhile(!q.empty()){\n\t\tTreeNode* node = q.front(); //取出队列首结点 \n\t\tq.pop(); //弹出首结点 \n\t\tprintf(\"%d\",node->val);\n\t\tcount++;\n\t\tif(count<n) printf(\" \");\n\t\tif(node->left){\n\t\t\tq.push(node->left);\n\t\t}\n\t\tif(node->right){\n\t\t\tq.push(node->right);\n\t\t}\n\t}\n\t\n} \nint main() {\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&post[i]);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&in[i]);\n\t}\n\tTreeNode* root = createTree(0,n-1,0,n-1);\n\tlevelTraver(root);\n\treturn 0;\n}\n```\n","content":"<hr>\n<a id=\"more\"></a>\n<h3 id=\"树与二叉树\"><a href=\"#树与二叉树\" class=\"headerlink\" title=\"树与二叉树\"></a>树与二叉树</h3><h4 id=\"1020-Tree-Traversals\"><a href=\"#1020-Tree-Traversals\" class=\"headerlink\" title=\"1020 Tree Traversals\"></a>1020 Tree Traversals</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;cstdio&gt;</span><br><span class=\"line\">#include&lt;algorithm&gt;</span><br><span class=\"line\">#include&lt;queue&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">const int MAXN=50; //最大的结点数 </span><br><span class=\"line\">int n;</span><br><span class=\"line\">int post[MAXN],in[MAXN];//用于保存后序和中序遍历结点的数组</span><br><span class=\"line\">/*定义树结点结构*/</span><br><span class=\"line\">struct TreeNode &#123;</span><br><span class=\"line\">\tint val;</span><br><span class=\"line\">\tstruct TreeNode *left;</span><br><span class=\"line\">\tstruct TreeNode *right;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">/*根据中序和后续递归创建树*/</span><br><span class=\"line\">TreeNode *createTree(int postL,int postR,int inL,int inR) &#123;</span><br><span class=\"line\">\tif(postL &gt; postR) &#123; //递归边界</span><br><span class=\"line\">\t\treturn NULL;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tTreeNode *root = new TreeNode();//创建根结点</span><br><span class=\"line\">\troot-&gt;val = post[postR];</span><br><span class=\"line\">\tint k=0;</span><br><span class=\"line\">\tfor(k = 0; k &lt; n; k++) &#123; //计算出根结点在中序序列的位置</span><br><span class=\"line\">\t\tif(in[k]==post[postR]) &#123;</span><br><span class=\"line\">\t\t\tbreak;                </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint numberLeft = k-inL; //左子树的结点数 3</span><br><span class=\"line\">\troot-&gt;left = createTree(postL,postL+numberLeft-1,inL,inL+numberLeft-1); //下标是从0开始的 </span><br><span class=\"line\">\troot-&gt;right = createTree(postL+numberLeft,postR-1,inL+numberLeft+1,inR);</span><br><span class=\"line\">\treturn root; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 层序遍历 */</span><br><span class=\"line\">void levelTraver(TreeNode* root)&#123;</span><br><span class=\"line\">\tint count = 0;</span><br><span class=\"line\">\tqueue&lt;TreeNode*&gt; q;//创建一个队列 </span><br><span class=\"line\">\tq.push(root);</span><br><span class=\"line\">\twhile(!q.empty())&#123;</span><br><span class=\"line\">\t\tTreeNode* node = q.front(); //取出队列首结点 </span><br><span class=\"line\">\t\tq.pop(); //弹出首结点 </span><br><span class=\"line\">\t\tprintf(&quot;%d&quot;,node-&gt;val);</span><br><span class=\"line\">\t\tcount++;</span><br><span class=\"line\">\t\tif(count&lt;n) printf(&quot; &quot;);</span><br><span class=\"line\">\t\tif(node-&gt;left)&#123;</span><br><span class=\"line\">\t\t\tq.push(node-&gt;left);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif(node-&gt;right)&#123;</span><br><span class=\"line\">\t\t\tq.push(node-&gt;right);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tscanf(&quot;%d&quot;,&amp;n);</span><br><span class=\"line\">\tfor(int i=0;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\tscanf(&quot;%d&quot;,&amp;post[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfor(int i=0;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\tscanf(&quot;%d&quot;,&amp;in[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tTreeNode* root = createTree(0,n-1,0,n-1);</span><br><span class=\"line\">\tlevelTraver(root);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","slug":"pat","excerpt":"","categories":[{"name":"Data Structure & Algorithm","slug":"Data-Structure-Algorithm","permalink":"http://yoursite.com/categories/Data-Structure-Algorithm/"}],"tags":[]},{"title":"版本控制工具的使用","date":"2019-06-16T07:00:55.000Z","path":"2019/06/16/subversion/","text":"概述在开发过程中，我们避免不了要管理我们编写的代码（比如要回退到某一时刻的版本、多人协作编写代码等），版本控制工具就是起到这样一个作用。版本控制系统有两种,一种是集中式，一种是分布式。集中式就是中央服务器保存所有文件的历史版本，我们通过客户端获取最新版本。分布式：每台电脑都保留着完整的历史版本，多人协同开发时通过推送的方式保持代码的一致。以下是通过虚拟机VMware中的CentOS进行的操作。 SVNCentOS安装svn服务器1# yum install subversion 创建版本库12# mkdir #创建目录# svnadmin create #将上面创建的目录指定为svn版本库 创建用户、配置相关的权限创建完成后，通过命令查看目录中的文件，发现svn为我们创建了：在这里我们主要关注conf目录中的三个文件passwd用于设置用户名和密码，authz主要用于设置组别和用户的权限，svnserve.conf用于全局设置（如匿名访问者的权限）。具体的配置可见每个文件当中的注释信息。这里不再赘述。最后启动服务：1# svnserve -d -r 目录 --listen-port 端口号 SVN默认监听端口号3690。 通过客户端进行访问下载TortoiseSVN客户端 并进行安装。常用的功能：Checkout（提取）:获取服务器上的源代码Commit（提交）:提交编写的代码Update (更新):从服务器上获取最新的代码版本Revert（版本回退）:撤销任何文件或目录里的局部更改","raw":"title: 版本控制工具的使用\ncategories: 版本控制\ndate: 2019-06-16 15:00:55\n---\n---\n<!--more-->\n# 概述\n在开发过程中，我们避免不了要管理我们编写的代码（比如要回退到某一时刻的版本、多人协作编写代码等），版本控制工具就是起到这样一个作用。版本控制系统有两种,一种是集中式，一种是分布式。集中式就是中央服务器保存所有文件的历史版本，我们通过客户端获取最新版本。分布式：每台电脑都保留着完整的历史版本，多人协同开发时通过推送的方式保持代码的一致。以下是通过虚拟机VMware中的CentOS进行的操作。\n# SVN\n\n## CentOS安装svn服务器\n```\n# yum install subversion\n```\n## 创建版本库\n```\n# mkdir   #创建目录\n# svnadmin create  #将上面创建的目录指定为svn版本库\n```\n## 创建用户、配置相关的权限\n创建完成后，通过命令查看目录中的文件，发现svn为我们创建了：![explanation](/uploads/svn1.png)在这里我们主要关注`conf`目录中的三个文件![explanation](/uploads/svn.png)`passwd`用于设置用户名和密码，`authz`主要用于设置组别和用户的权限，`svnserve.conf`用于全局设置（如匿名访问者的权限）。具体的配置可见每个文件当中的注释信息。这里不再赘述。\n最后启动服务：\n```\n# svnserve -d -r 目录 --listen-port 端口号\n```\nSVN默认监听端口号3690。\n\n## 通过客户端进行访问\n下载`TortoiseSVN客户端` 并进行安装。\n常用的功能：\n**Checkout（提取）**:获取服务器上的源代码 \n**Commit（提交）**:提交编写的代码\n**Update (更新)**:从服务器上获取最新的代码版本\n**Revert（版本回退）**:撤销任何文件或目录里的局部更改\n","content":"<hr>\n<a id=\"more\"></a>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>在开发过程中，我们避免不了要管理我们编写的代码（比如要回退到某一时刻的版本、多人协作编写代码等），版本控制工具就是起到这样一个作用。版本控制系统有两种,一种是集中式，一种是分布式。集中式就是中央服务器保存所有文件的历史版本，我们通过客户端获取最新版本。分布式：每台电脑都保留着完整的历史版本，多人协同开发时通过推送的方式保持代码的一致。以下是通过虚拟机VMware中的CentOS进行的操作。</p>\n<h1 id=\"SVN\"><a href=\"#SVN\" class=\"headerlink\" title=\"SVN\"></a>SVN</h1><h2 id=\"CentOS安装svn服务器\"><a href=\"#CentOS安装svn服务器\" class=\"headerlink\" title=\"CentOS安装svn服务器\"></a>CentOS安装svn服务器</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># yum install subversion</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建版本库\"><a href=\"#创建版本库\" class=\"headerlink\" title=\"创建版本库\"></a>创建版本库</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># mkdir   #创建目录</span><br><span class=\"line\"># svnadmin create  #将上面创建的目录指定为svn版本库</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建用户、配置相关的权限\"><a href=\"#创建用户、配置相关的权限\" class=\"headerlink\" title=\"创建用户、配置相关的权限\"></a>创建用户、配置相关的权限</h2><p>创建完成后，通过命令查看目录中的文件，发现svn为我们创建了：<img src=\"/uploads/svn1.png\" alt=\"explanation\">在这里我们主要关注<code>conf</code>目录中的三个文件<img src=\"/uploads/svn.png\" alt=\"explanation\"><code>passwd</code>用于设置用户名和密码，<code>authz</code>主要用于设置组别和用户的权限，<code>svnserve.conf</code>用于全局设置（如匿名访问者的权限）。具体的配置可见每个文件当中的注释信息。这里不再赘述。<br>最后启动服务：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># svnserve -d -r 目录 --listen-port 端口号</span><br></pre></td></tr></table></figure></p>\n<p>SVN默认监听端口号3690。</p>\n<h2 id=\"通过客户端进行访问\"><a href=\"#通过客户端进行访问\" class=\"headerlink\" title=\"通过客户端进行访问\"></a>通过客户端进行访问</h2><p>下载<code>TortoiseSVN客户端</code> 并进行安装。<br>常用的功能：<br><strong>Checkout（提取）</strong>:获取服务器上的源代码<br><strong>Commit（提交）</strong>:提交编写的代码<br><strong>Update (更新)</strong>:从服务器上获取最新的代码版本<br><strong>Revert（版本回退）</strong>:撤销任何文件或目录里的局部更改</p>\n","slug":"subversion","excerpt":"","categories":[{"name":"版本控制","slug":"版本控制","permalink":"http://yoursite.com/categories/版本控制/"}],"tags":[]},{"title":"leetcode题解","date":"2019-05-10T01:13:00.000Z","path":"2019/05/10/leetcode题解/","text":"LinkedList常用的解题方法 遍历链表 利用递归的思想，如反转链表 双指针：快慢指针 Remove Duplicates from Sorted List思路：遍历链表，在遍历时判断当前结点的值与后面结点的值是否相等，时间复杂度O(n)。 12345678910111213class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; ListNode cur = head; //cur为遍历指针 while(cur != null&amp;&amp;cur.next != null)&#123; if(cur.val == cur.next.val)&#123; cur.next = curt.next.next; &#125;else &#123; cur = cur.next; &#125; &#125; return head; &#125;&#125; Remove Duplicates from Sorted List II思路：采用双指针，一个指针指向需要保留的结点，一个指针对有重复值的结点进行查找。123456789101112131415161718public ListNode deleteDuplicates(ListNode head) &#123; if(head == null) return head; ListNode dummy = new ListNode(0); dummy.next = head; //创建一个虚的头结点，方便后续的操作判断 ListNode pre = dummy,cur = head;//双指针，pre指向需要保留的结点，cur为查重指针 while(cur != null)&#123; while (cur.next != null&amp;&amp;cur.val == cur.next.val)&#123; //如果出现相等的结点，就把当前指针指到相等结点的最后一个,注意：并没有删除结点 cur = cur.next; &#125; if(pre.next == cur) &#123; //说明这是一个有唯一值的结点，cur指针还没有动过呢,通过cur指针是否有移动来判断是否存在等值结点 pre = pre.next; &#125; else&#123; //如果有一堆相等的结点，那就进行批量的删除 pre.next = cur.next; //这边pre指针没有动过哦，只是修改它指向的下一个的结点 &#125; cur = cur.next; &#125; return dummy.next;&#125; Linked List Cycle思路：采用快慢指针的思想。如果存在环，快指针终归会追上慢指针1234567891011public boolean hasCycle(ListNode head) &#123; if(head == null || head.next == null) return false; ListNode fast,slow; fast=slow = head; while(fast != null &amp;&amp; fast.next != null)&#123; //注意这边判断的写法，同时对前后两个结点进行判断 fast = fast.next.next;//fast每次走两步，slow每次走一步 slow = slow.next; if(fast == slow) return true; &#125; return false;&#125; Linked List Cycle II思路：与上题的思想基本一致。只是…看图：1234567891011121314151617181920public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; if (head == null || head.next == null) return null; ListNode fast, slow; fast = slow = head; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; if (fast == slow) &#123; fast = head; while (fast != slow) &#123; fast = fast.next; slow = slow.next; &#125; return fast; &#125; &#125; return null; &#125;&#125; Odd Even Linked List思路：采用双指针的思想，可以想象成分成两个链表，一个下标为偶数的链表，一个下标为奇数的链表，pre、cur分别指向两个链表的末尾结点。123456789101112131415class Solution &#123; public ListNode oddEvenList(ListNode head) &#123; if (head == null || head.next == null||head.next.next==null) return head; //结点为空，一个结点，两个结点的情况 ListNode pre = head, cur = head.next;//pre指向偶数链表的末结点，cur指向奇数链表的末结点。 while (cur != null &amp;&amp; cur.next != null) &#123; ListNode tmp = pre.next; //先保存要拼接的结点 pre.next = cur.next; cur.next = cur.next.next; //每次只进行一个结点的连接 pre.next.next=tmp; //进行拼接 cur = cur.next; pre = pre.next; &#125; return head; &#125;&#125; Palindrome Linked List思路：使用快慢指针和栈。通过快指针可以知道慢指针什么时候遍历到了中点。1234567891011121314151617181920class Solution &#123; public boolean isPalindrome(ListNode head) &#123; if (head == null || head.next == null) return true; ListNode slow = head, fast = head; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(head.val); while (fast.next != null &amp;&amp; fast.next.next != null) &#123; slow = slow.next; fast = fast.next.next; stack.push(slow.val); &#125; if (fast.next == null) stack.pop();//结点为奇数个的时候，需要将一个结点先弹出 while (slow.next != null) &#123; slow = slow.next; int tmp = stack.pop(); if (tmp != slow.val) return false; &#125; return true; &#125;&#125; Intersection of Two Linked Lists思路：一种方法是求得两条链表的结点个数差n，然后让长的链先走n，然后再同时遍历，比较两个结点的地址是相等。另一种方法是：通过环的思想，进行交叉遍历，让两个指针都走完相同的路程。1234567891011public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if (headA == null || headB == null) return null; ListNode p = headA, q = headB; while (p != q) &#123; p = p == null ? headB : p.next; q = q == null ? headA : q.next; &#125; return p; &#125;&#125; Sort List思路：采用快慢指针查找到中间结点，进行递归的归并排序12345678910111213141516171819202122232425class Solution &#123; public ListNode sortList(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode pre = head, slow = head, fast = head; while (fast != null &amp;&amp; fast.next != null) &#123; pre = slow; slow = slow.next; fast = fast.next.next; &#125; pre.next = null; return merge(sortList(head), sortList(slow)); &#125; ListNode merge(ListNode l1, ListNode l2) &#123; if (l1 == null) return l2; if (l2 == null) return l1; if (l1.val &lt; l2.val) &#123; l1.next = merge(l1.next, l2); return l1; &#125; else &#123; l2.next = merge(l1, l2.next); return l2; &#125; &#125;&#125; Delete Node in a Linked List思路：将要删除的结点的值设为下个结点的值，将下个结点删除。1234567class Solution &#123; public void deleteNode(ListNode node) &#123; ListNode q = node.next; node.val = q.val; node.next = q.next; &#125;&#125; String常用的解题方法 运用哈希 使用双指针 反转字符串 II思路：每隔2k个字符开始遍历，然后进行反转。123456789class Solution &#123; public: string reverseStr(string s, int k) &#123; for (int i = 0; i &lt; s.size(); i += 2 * k) &#123; reverse(s.begin() + i, min(s.begin() + i + k, s.end())); &#125; return s; &#125;&#125;; Implement strStr()思想：1.暴力破解，如果发生不匹配主串可能需要回溯。2.KMP算法。1234567891011121314151617class Solution &#123; public int strStr(String haystack, String needle) &#123; int i = 0, j = 0; int len1 = haystack.length(), len2 = needle.length(); while (i &lt; len1 &amp;&amp; j &lt; len2) &#123; if (haystack.charAt(i) == needle.charAt(j)) &#123; i++; j++; &#125; else &#123; i = i - j + 1; j = 0; &#125; &#125; if (j &gt;= len2) return i - j; else return -1; &#125;&#125; Valid Anagram思想：创建一个哈希数组，如果两个字符串含有同样的单词则将该位置的值置为0。123456789101112131415class Solution &#123; public boolean isAnagram(String s, String t) &#123; if (s.length() != t.length()) return false; if (s == null || t == null) return false; int[] map = new int[256]; for (int i = 0; i &lt; s.length(); i++) &#123; map[s.charAt(i)]++; map[t.charAt(i)]--; &#125; for (Integer i : map) &#123; if (i != 0) return false; &#125; return true; &#125;&#125; Valid Palindrome思路：采用双指针的思想，在这当中，使用了java提供的一些函数。1234567891011121314151617181920212223242526class Solution &#123; public boolean isPalindrome(String s) &#123; if (s == null || s.trim().isEmpty()) &#123; return true; &#125; int l = 0, r = s.length() - 1; while (l &lt; r) &#123; if (!Character.isLetterOrDigit(s.charAt(l))) &#123; //非字母或者数字的情况下。 l++; continue; &#125; if (!Character.isLetterOrDigit(s.charAt(r))) &#123; r--; continue; &#125; if (Character.toLowerCase(s.charAt(l)) == Character.toLowerCase(s.charAt(r))) &#123; l++; r--; &#125; else &#123; return false; &#125; &#125; return true; &#125;&#125; Array常用的解题方法 遍历数组，标记变量 双指针 39. Combination Sum主要思路：递归、回溯。画出图可以帮助理解。123456789101112131415161718192021class Solution &#123; private List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); //用于保存结果 private Stack&lt;Integer&gt; pre = new Stack&lt;&gt;(); private void findCombinationSum(int start, int residue, int[] candidates, Stack&lt;Integer&gt; pre) &#123; if (residue == 0) &#123; res.add(new ArrayList&lt;&gt;(pre)); &#125; for (int i = start; i &lt; candidates.length &amp;&amp; residue - candidates[i] &gt;= 0; i++) &#123; pre.add(candidates[i]); findCombinationSum(i, residue - candidates[i], candidates, pre); pre.pop(); &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; Arrays.sort(candidates); findCombinationSum(0, target, candidates, pre); return res; &#125;&#125; 40. Combination Sum II123456789101112131415161718192021222324class Solution &#123; private List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); //保存结果的数组 private Stack&lt;Integer&gt; pre = new Stack&lt;&gt;(); private void findCombinationSum(int start, int residue, int[] candidates, Stack&lt;Integer&gt; pre) &#123; if (residue == 0) &#123; res.add(new ArrayList&lt;&gt;(pre)); &#125; for (int i = start; i &lt; candidates.length &amp;&amp; residue - candidates[i] &gt;= 0; i++) &#123; if (i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) &#123; continue; &#125; pre.add(candidates[i]); findCombinationSum(i + 1, residue - candidates[i], candidates, pre); pre.pop(); &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; Arrays.sort(candidates); findCombinationSum(0, target, candidates, pre); return res; &#125;&#125; PascalsTriangle123456789101112131415161718class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; numRows; i++) &#123; List&lt;Integer&gt; row = new ArrayList&lt;&gt;(); for (int j = 0; j &lt;= i; j++) &#123; if (i == 0 || j == 0 || i == j) &#123; row.add(1); &#125; else &#123; List&lt;Integer&gt; pre = res.get(i - 1); row.add(pre.get(j - 1) + pre.get(j)); &#125; &#125; res.add(row); &#125; return res; &#125;&#125; Remove Duplicates from Sorted Array思路：使用双指针，一个指针为遍历指针；另一个指针指向结果数组的每个位置，判断该位置要填充的元素。1234567891011class Solution &#123; public int removeDuplicates(int[] nums) &#123; int index = 0; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] != nums[index]) &#123; nums[++index] = nums[i];//0号位置的值已经确定，从1号位置开始 &#125; &#125; return index + 1; &#125;&#125; Remove Duplicates from Sorted Array II思路：同上题的思路相同，只是多一个变量count对元素的数量进行统计。123456789101112131415class Solution &#123; public int removeDuplicates(int[] nums) &#123; int index = 0, count = 0; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[index] == nums[i]) &#123; count++; if (count &lt; 2) nums[++index] = nums[i]; &#125; else &#123; count = 0; nums[++index] = nums[i]; &#125; &#125; return index + 1; &#125;&#125; Remove Element思路：双指针，在遍历时用另一个指针确定结果数组的每一个位置的最终值1234567891011class Solution &#123; public int removeElement(int[] nums, int val) &#123; int index = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] != val) &#123; nums[index++] = nums[i]; &#125; &#125; return index; &#125;&#125; Majority Element思路：设置变量majority存储可能是众数的元素，设置一个计数器count对元素的出现次数进行计数，在遍历数组的过程操作count变量进行一些操作。1234567891011121314class Solution &#123; public int majorityElement(int[] nums) &#123; int count = 0; int majority = nums[0]; for (int i = 0; i &lt; nums.length; i++) &#123; if (count == 0) majority = nums[i]; if (majority == nums[i]) count++; else &#123; count--; &#125; &#125; return majority; &#125;&#125; Search a 2D MatrixSearch a 2D Matrix II思路：根据题目的条件可知数组是有规律的，按照规律以某个元素所在行和列进行搜索，而减少对整个数组进行搜索。每个元素的行和列构成递增序列。123456789101112131415161718class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; int rows = matrix.length; if (rows == 0) return false; int cols = matrix[0].length; int i = 0, j = cols - 1; //右上角第一个元素的坐标 while (i &lt; rows &amp;&amp; j &gt;= 0) &#123; if (matrix[i][j] == target) &#123; return true; &#125; else if (matrix[i][j] &gt; target) &#123; j--; &#125; else &#123; i++; &#125; &#125; return false; &#125;&#125; Move Zeroes思路：先将前面非零数字进行填充，将数组之后空的位置填充上零。12345678910111213class Solution &#123; public void moveZeroes(int[] nums) &#123; int index = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] != 0) &#123; nums[index++] = nums[i]; &#125; &#125; for (int i = index; i &lt; nums.length; i++) &#123; nums[i] = 0; &#125; &#125;&#125; Intersection of Two Arrays思路：通过java提供的数据结构Set来帮助简化我们做题，用contains()方法啊，使得我们不用再去写遍历操作12345678910111213141516class Solution &#123; public int[] intersection(int[] nums1, int[] nums2) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); Set&lt;Integer&gt; res = new HashSet&lt;&gt;(); for(int n : nums1) set.add(n); for(int n : nums2) if(set.contains(n)) res.add(n); int[] result = new int[res.size()]; int index = 0 ; for(int n : res) result[index++] = n; return result; &#125;&#125; Intersection of Two Arrays II思路：设置一个hash数组统计数组当中每个元素出现的次数。1234567891011121314151617class Solution &#123; public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp;nums1, vector&lt;int&gt;&amp;nums2) &#123; vector&lt;int&gt; res; map&lt;int, int&gt; mp; for (int i = 0; i &lt; nums1.size(); i++) &#123; mp[nums1[i]]++; &#125; for (int i = 0; i &lt; nums2.size(); i++) &#123; if (mp[nums2[i]] &gt; 0) &#123; res.push_back(nums2[i]); mp[nums2[i]]--; &#125; &#125; return res; &#125;&#125;; Kth Largest Element in an Array思路：先进行排序，再得出结果123456class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; Arrays.sort(nums); return nums[nums.length - k]; &#125;&#125; stack需要掌握的思想 模拟进出栈 用栈解决问题的思想 Min Stack思路：用两个栈，一个栈为最小值栈，一个栈为真实数据栈。或者用一个栈也可以。12345678910111213141516171819202122232425262728293031323334class MinStack &#123; /** * initialize your data structure here. */ private Stack&lt;Integer&gt; min, data; //min为最小值栈。 public MinStack() &#123; //初始化两个栈 min = new Stack&lt;&gt;(); data = new Stack&lt;&gt;(); &#125; public void push(int x) &#123; data.push(x); if (min.empty() || min.peek() &gt;= x) &#123; min.push(x); &#125; &#125; public void pop() &#123; if ((int) data.peek() == (int) min.peek()) &#123; //通过peek()方法返回的为对象，两个不同的对象进行比较总是不相等的，所以需要进行强转。 min.pop(); &#125; data.pop(); &#125; public int top() &#123; return data.peek(); &#125; public int getMin() &#123; return min.peek(); &#125;&#125; TreeBinary Tree Preorder Traversal思路：非递归遍历，根据访问的顺序：根-&gt;左-&gt;右。1234567891011121314class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); if (root != null) stack.push(root); while (!stack.empty()) &#123; TreeNode node = stack.pop(); res.add(node.val); if (node.right != null) stack.push(node.right);//将还没访问的结点入栈 if (node.left != null) stack.push(node.left); &#125; return res; &#125;&#125; 递归写法：12345678910111213class Solution &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; if (root == null) &#123; return list; &#125; list.add(root.val); preorderTraversal(root.left); preorderTraversal(root.right); return list; &#125;&#125; Binary Tree Inorder Traversal非递归写法：123456789101112131415161718class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode node = root; while (!stack.empty() || node != null) &#123; if (node != null) &#123; stack.push(node); node = node.left; &#125; else &#123; node = stack.pop(); res.add(node.val); node = node.right; &#125; &#125; return res; &#125;&#125; 递归写法：12345678910111213class Solution &#123; List&lt;Integer&gt; list = new ArrayList(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; if (root == null) &#123; return list; &#125; inorderTraversal(root.left); list.add(root.val); inorderTraversal(root.right); return list; &#125;&#125; Binary Tree Postorder Traversal非递归写法：1234567891011121314151617181920212223242526class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode p = root, q = null; do &#123; while (p != null) &#123; //将左边的结点全部压入栈 stack.push(p); p = p.left; &#125; q = null; while (!stack.empty()) &#123; //查看出栈结点的右结点是否为空 p = stack.pop(); if (p.right == q) &#123; res.add(p.val); q = p; &#125; else &#123; stack.push(p); p = p.right; //转换成右边的结点 break; &#125; &#125; &#125; while (!stack.empty()); return res; &#125;&#125; 递归写法：12345678910111213class Solution &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; if (root == null) &#123; return list; &#125; postorderTraversal(root.left); postorderTraversal(root.right); list.add(root.val); return list; &#125;&#125; Kth Smallest Element in a BST思路：根据二叉搜索树的特性，选择用中序遍历的思想，设置变量统计当前访问到的结点，如果与所求结点k相等，则返回。12345678910111213141516171819class Solution &#123; int count = 0; TreeNode res; public int kthSmallest(TreeNode root, int k) &#123; InorderTraversal(root, k); return res.val; &#125; public void InorderTraversal(TreeNode root, int k) &#123; if (root.left != null) InorderTraversal(root.left, k); count++; if (count == k) &#123; res = root; return; &#125; if (root.right != null) InorderTraversal(root.right, k); &#125;&#125; Lowest Common Ancestor of a Binary Tree递归时需要建立总体的观念123456789class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null || p == root || q == root) return root; //当p和q当中有一个为根结点，则返回根结点 TreeNode left = lowestCommonAncestor(root.left, p, q); //递归时需要建立全局的观念 TreeNode right = lowestCommonAncestor(root.right, p, q); if(left!=null&amp;&amp;right!=null) return root; //若p、q在分在左右子树之间，则返回根结点 return left!=null ? left:right; //若p、q同在左子树或者右子树，则返回不为空的结点 &#125;&#125; Binary Tree Level Order Traversal思路：使用深度优先遍历或者辅助队列12345678910111213141516171819class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); dfs(root,0,res); return res; &#125; public void dfs(TreeNode root, int depth, List&lt;List&lt;Integer&gt;&gt; res) &#123; if (root != null) &#123; if (res.size() &lt; depth + 1) &#123; res.add(depth, new ArrayList&lt;Integer&gt;()); &#125; res.get(depth).add(root.val); depth++; if(root.left!=null) dfs(root.left,depth,res); if(root.right!=null) dfs(root.right,depth,res); &#125; &#125;&#125; Binary Tree Level Order Traversal II思路：和上一题的思路是一致的，只是在最后加入结果集时需要将其插入到头部。12345678910111213141516171819class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; LinkedList&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); if (root == null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = queue.size(); i &gt; 0; i--) &#123; TreeNode node = queue.poll(); list.add(node.val); if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); &#125; res.offerFirst(list); //将其插入到链表的头部 &#125; return res; &#125;&#125; Average of Levels in Binary Tree1234567891011121314151617181920class Solution &#123; public List&lt;Double&gt; averageOfLevels(TreeNode root) &#123; List&lt;Double&gt; res = new LinkedList&lt;&gt;(); if (root == null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) &#123; int size = queue.size(); double sum = 0; for (int i = size; i &gt; 0; i--) &#123; TreeNode node = queue.poll(); if (node != null) sum += node.val; if (node.left != null) queue.add(node.left); if (node.right != null) queue.add(node.right); &#125; res.add(sum / size); &#125; return res; &#125;&#125; N-ary Tree Level Order Traversal递归算法：1234567891011121314151617181920class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); dfs(root, 0, res); return res; &#125; public void dfs(Node root, int depth, List&lt;List&lt;Integer&gt;&gt; res) &#123; if (root != null) &#123; if (res.size() &lt; depth + 1) &#123; //根据层数判断需要创建多少个的List res.add(depth, new ArrayList&lt;Integer&gt;()); &#125; res.get(depth).add(root.val); //从特殊情况-&gt;一般情况 depth++; for (Node child : root.children) &#123; dfs(child, depth, res); &#125; &#125; &#125;&#125; 非递归算法：1234567891011121314151617181920class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (root == null) return res; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = queue.size(); i &gt; 0; i--) &#123; //一开始就必须获得队列的大小（队列是在不断变化的），队列当中当前层的全部结点 Node node = queue.poll(); list.add(node.val); for (Node child : node.children) &#123; queue.add(child); &#125; &#125; res.add(list); &#125; return res; &#125;&#125; Path Sum 12345678class Solution &#123; public boolean hasPathSum(TreeNode root, int sum) &#123; if (root == null) return false; sum -= root.val; if (root.right == null &amp;&amp; root.left == null) return sum == 0; //判断最后根节点到叶子结点的路径和是否为零。 return hasPathSum(root.left, sum) || hasPathSum(root.right, sum); &#125; Path Sum II123456789101112131415161718class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); helper(res,new ArrayList&lt;&gt;(),root,sum); return res; &#125; public void helper(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, TreeNode root, int sum) &#123; if (root == null) return; list.add(root.val); if (root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == sum) &#123; res.add(new ArrayList&lt;&gt;(list)); &#125; helper(res,list,root.left,sum-root.val); helper(res,list,root.right,sum-root.val); list.remove(list.size()-1); //进行回溯。 &#125;&#125; Path Sum III思路：1.计算以某个结点为路径起始点的符合条件数。2.遍历所有的结点，并递归执行1步骤。12345678910111213class Solution &#123;public: int pathSum(TreeNode* root, int sum) &#123; //遍历每个结点，每个结点都作为根计算路径 if (root == NULL) return 0; return helper(root, sum) + pathSum(root -&gt; left, sum) + pathSum(root -&gt; right, sum); &#125; int helper(TreeNode* root, int sum) &#123; //以root为根作为一条路径，计算该路径上符合条件的数目 if (root == NULL) return 0; sum -= root -&gt; val; //sum为0的情况下即是符合路径 return (sum == 0 ? 1 : 0) + helper(root -&gt; left, sum) + helper(root -&gt; right, sum); &#125;&#125;; 递归反转字符串123456789101112131415class Solution &#123; public void reverseString(char[] s) &#123; swap(0, s.length - 1, s); &#125; public void swap(int start, int end, char[] s) &#123; if (start &gt;= end) &#123; //递归边界 return; &#125; char tmp = s[start]; s[start] = s[end]; s[end] = tmp; swap(start + 1, end - 1, s); &#125;&#125; 两两交换链表中的节点1234567891011class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if (head == null || head.next == null) &#123; //递归边界 return head; &#125; ListNode next = head.next; //递归体 head.next = swapPairs(next.next); next.next = head; return next; &#125;&#125;","raw":"title: leetcode题解\ncategories:\n  - Data Structure & Algorithm\ndate: 2019-05-10 09:13:00\n---\n---\n<!--more-->\n## LinkedList\n常用的解题方法\n> * 遍历链表\n> * 利用递归的思想，如反转链表\n> * 双指针：快慢指针\n\n### [Remove Duplicates from Sorted List](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list)\n思路：遍历链表，在遍历时判断当前结点的值与后面结点的值是否相等，时间复杂度O(n)。\n\n``` java\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        ListNode cur = head; //cur为遍历指针\n        while(cur != null&&cur.next != null){\n            if(cur.val == cur.next.val){\n                cur.next = curt.next.next;\n            }else {\n                cur = cur.next;\n            }\n        }\n        return head;\n    }\n}\n```\n### [Remove Duplicates from Sorted List II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)\n思路：采用双指针，一个指针指向需要保留的结点，一个指针对有重复值的结点进行查找。\n``` java\n\t   public ListNode deleteDuplicates(ListNode head) {\n        if(head == null) return head;\n        ListNode dummy = new ListNode(0);\n        dummy.next = head; //创建一个虚的头结点，方便后续的操作判断\n        ListNode pre = dummy,cur = head;//双指针，pre指向需要保留的结点，cur为查重指针\n        while(cur != null){\n            while (cur.next != null&&cur.val == cur.next.val){ //如果出现相等的结点，就把当前指针指到相等结点的最后一个,注意：并没有删除结点\n                cur = cur.next;\n            }\n            if(pre.next == cur) {  //说明这是一个有唯一值的结点，cur指针还没有动过呢,通过cur指针是否有移动来判断是否存在等值结点\n                pre = pre.next;\n            } else{    //如果有一堆相等的结点，那就进行批量的删除\n                pre.next = cur.next; //这边pre指针没有动过哦，只是修改它指向的下一个的结点\n            }\n            cur = cur.next;\n        }\n        return dummy.next;\n    }\n```\n### [Linked List Cycle](https://leetcode-cn.com/problems/linked-list-cycle)\n思路：采用快慢指针的思想。如果存在环，快指针终归会追上慢指针\n``` java\n    public boolean hasCycle(ListNode head) {\n        if(head == null || head.next == null) return false;\n        ListNode fast,slow;\n        fast=slow = head;\n        while(fast != null && fast.next != null){ //注意这边判断的写法，同时对前后两个结点进行判断\n           fast = fast.next.next;//fast每次走两步，slow每次走一步\n           slow = slow.next;\n           if(fast == slow) return true;\n        }\n        return false;\n    }\n```\n### [Linked List Cycle II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\n思路：与上题的思想基本一致。只是...看图：\n![explanation](/uploads/LinkList.jpg)\n``` java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null) return null;\n        ListNode fast, slow;\n        fast = slow = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) {\n                fast = head;\n                while (fast != slow) {\n                    fast = fast.next;\n                    slow = slow.next;\n                }\n                return fast;\n            }\n        }\n        return null;\n    }\n}\n```\n### [Odd Even Linked List](https://leetcode-cn.com/problems/odd-even-linked-list/)\n思路：采用双指针的思想，可以想象成分成两个链表，一个下标为偶数的链表，一个下标为奇数的链表，pre、cur分别指向两个链表的末尾结点。\n```java\nclass Solution {\n    public ListNode oddEvenList(ListNode head) {\n        if (head == null || head.next == null||head.next.next==null) return head; //结点为空，一个结点，两个结点的情况\n        ListNode pre = head, cur = head.next;//pre指向偶数链表的末结点，cur指向奇数链表的末结点。\n        while (cur != null && cur.next != null) {\n            ListNode tmp = pre.next; //先保存要拼接的结点\n            pre.next = cur.next;\n            cur.next = cur.next.next; //每次只进行一个结点的连接\n            pre.next.next=tmp;  //进行拼接\n            cur = cur.next;\n            pre = pre.next;\n        }\n        return head;\n    }\n}\n```\n### [Palindrome Linked List](https://leetcode-cn.com/problems/palindrome-linked-list/)\n思路：使用快慢指针和栈。通过快指针可以知道慢指针什么时候遍历到了中点。\n```java\nclass Solution {\n    public boolean isPalindrome(ListNode head) {\n        if (head == null || head.next == null) return true;\n        ListNode slow = head, fast = head;\n        Stack<Integer> stack = new Stack<>();\n        stack.push(head.val);\n        while (fast.next != null && fast.next.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            stack.push(slow.val);\n        }\n        if (fast.next == null) stack.pop();//结点为奇数个的时候，需要将一个结点先弹出\n        while (slow.next != null) {\n            slow = slow.next;\n            int tmp = stack.pop();\n            if (tmp != slow.val) return false;\n        }\n        return true;\n    }\n}\n```\n### [Intersection of Two Linked Lists](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\n思路：一种方法是求得两条链表的结点个数差n，然后让长的链先走n，然后再同时遍历，比较两个结点的地址是相等。另一种方法是：通过环的思想，进行交叉遍历，让两个指针都走完相同的路程。\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) return null;\n        ListNode p = headA, q = headB;\n        while (p != q) {\n            p = p == null ? headB : p.next;\n            q = q == null ? headA : q.next;\n        }\n        return p;\n    }\n}\n```\n### [Sort List](https://leetcode-cn.com/problems/sort-list/)\n思路：采用快慢指针查找到中间结点，进行递归的归并排序\n```java\nclass Solution {\n    public ListNode sortList(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode pre = head, slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            pre = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        pre.next = null;\n        return merge(sortList(head), sortList(slow));\n    }\n\n    ListNode merge(ListNode l1, ListNode l2) {\n        if (l1 == null) return l2;\n        if (l2 == null) return l1;\n        if (l1.val < l2.val) {\n            l1.next = merge(l1.next, l2);\n            return l1;\n        } else {\n            l2.next = merge(l1, l2.next);\n            return l2;\n        }\n    }\n}\n```\n### [Delete Node in a Linked List](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)\n思路：将要删除的结点的值设为下个结点的值，将下个结点删除。\n```java\nclass Solution {\n    public void deleteNode(ListNode node) {\n        ListNode q = node.next;\n        node.val = q.val;\n        node.next = q.next;\n    }\n}\n```\n## String\n常用的解题方法\n> * 运用哈希\n> * 使用双指针\n### [ 反转字符串 II](https://leetcode-cn.com/problems/reverse-string-ii)\n思路：每隔2k个字符开始遍历，然后进行反转。\n``` C++\nclass Solution {\n    public:\n    string reverseStr(string s, int k) {\n        for (int i = 0; i < s.size(); i += 2 * k) {\n            reverse(s.begin() + i, min(s.begin() + i + k, s.end())); \n        }\n        return s;\n    }\n};\n```\n\n### [Implement strStr()](https://leetcode-cn.com/problems/implement-strstr/)\n思想：1.暴力破解，如果发生不匹配主串可能需要回溯。2.KMP算法。\n``` java\nclass Solution {\n    public int strStr(String haystack, String needle) {\n        int i = 0, j = 0;\n        int len1 = haystack.length(), len2 = needle.length();\n        while (i < len1 && j < len2) {\n            if (haystack.charAt(i) == needle.charAt(j)) {\n                i++;\n                j++;\n            } else {\n                i = i - j + 1;\n                j = 0;\n            }\n        }\n        if (j >= len2) return i - j;\n        else return -1;\n    }\n}\n```\n### [Valid Anagram](https://leetcode-cn.com/problems/valid-anagram/)\n思想：创建一个哈希数组，如果两个字符串含有同样的单词则将该位置的值置为0。\n``` java\nclass Solution {\n    public boolean isAnagram(String s, String t) {\n        if (s.length() != t.length()) return false;\n        if (s == null || t == null) return false;\n        int[] map = new int[256];\n        for (int i = 0; i < s.length(); i++) {\n            map[s.charAt(i)]++;\n            map[t.charAt(i)]--;\n        }\n        for (Integer i : map) {\n            if (i != 0) return false;\n        }\n        return true;\n    }\n}\n```\n### [Valid Palindrome](https://leetcode-cn.com/problems/valid-palindrome/)\n思路：采用双指针的思想，在这当中，使用了java提供的一些函数。\n```java\nclass Solution {\n    public boolean isPalindrome(String s) {\n        if (s == null || s.trim().isEmpty()) {\n            return true;\n        }\n        int l = 0, r = s.length() - 1;\n        while (l < r) {\n            if (!Character.isLetterOrDigit(s.charAt(l))) { //非字母或者数字的情况下。\n                l++;\n                continue;\n            }\n            if (!Character.isLetterOrDigit(s.charAt(r))) {\n                r--;\n                continue;\n            }\n            if (Character.toLowerCase(s.charAt(l)) == Character.toLowerCase(s.charAt(r))) {\n                l++;\n                r--;\n            } else {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n```\n## Array\n常用的解题方法\n> * 遍历数组，标记变量\n> * 双指针\n### [39. Combination Sum]()\n主要思路：递归、回溯。画出图可以帮助理解。\n```\nclass Solution {\n    private List<List<Integer>> res = new ArrayList<>(); //用于保存结果\n    private Stack<Integer> pre = new Stack<>();\n\n    private void findCombinationSum(int start, int residue, int[] candidates, Stack<Integer> pre) {\n        if (residue == 0) {\n            res.add(new ArrayList<>(pre));\n        }\n        for (int i = start; i < candidates.length && residue - candidates[i] >= 0; i++) {\n            pre.add(candidates[i]);\n            findCombinationSum(i, residue - candidates[i], candidates, pre);\n            pre.pop();\n        }\n    }\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        findCombinationSum(0, target, candidates, pre);\n        return res;\n    }\n}\n```\n### [40. Combination Sum II]()\n```\nclass Solution {\n    private List<List<Integer>> res = new ArrayList<>(); //保存结果的数组\n    private Stack<Integer> pre = new Stack<>();\n\n    private void findCombinationSum(int start, int residue, int[] candidates, Stack<Integer> pre) {\n        if (residue == 0) {\n            res.add(new ArrayList<>(pre));\n        }\n        for (int i = start; i < candidates.length && residue - candidates[i] >= 0; i++) {\n            if (i > start && candidates[i] == candidates[i - 1]) {\n                continue;\n            }\n            pre.add(candidates[i]);\n            findCombinationSum(i + 1, residue - candidates[i], candidates, pre);\n            pre.pop();\n        }\n    }\n\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        findCombinationSum(0, target, candidates, pre);\n        return res;\n    }\n}\n```\n### [PascalsTriangle](https://leetcode-cn.com/problems/pascals-triangle/)\n```\nclass Solution {\n    public List<List<Integer>> generate(int numRows) {\n        List<List<Integer>> res = new ArrayList<>();\n        for (int i = 0; i < numRows; i++) {\n            List<Integer> row = new ArrayList<>();\n            for (int j = 0; j <= i; j++) {\n                if (i == 0 || j == 0 || i == j) {\n                    row.add(1);\n                } else {\n                    List<Integer> pre = res.get(i - 1);\n                    row.add(pre.get(j - 1) + pre.get(j));\n                }\n            }\n            res.add(row);\n        }\n        return res;\n    }\n}\n```\n### [Remove Duplicates from Sorted Array](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)\n思路：使用双指针，一个指针为遍历指针；另一个指针指向结果数组的每个位置，判断该位置要填充的元素。\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int index = 0;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] != nums[index]) {\n                nums[++index] = nums[i];//0号位置的值已经确定，从1号位置开始\n            }\n        }\n        return index + 1;\n    }\n}\n```\n### [Remove Duplicates from Sorted Array II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)\n思路：同上题的思路相同，只是多一个变量count对元素的数量进行统计。\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int index = 0, count = 0;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[index] == nums[i]) {\n                count++;\n                if (count < 2) nums[++index] = nums[i];\n            } else {\n                count = 0;\n                nums[++index] = nums[i];\n            }\n        }\n        return index + 1;\n    }\n}\n```\n### [Remove Element](https://leetcode-cn.com/problems/remove-element/)\n思路：双指针，在遍历时用另一个指针确定结果数组的每一个位置的最终值\n```java\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        int index = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] != val) {\n                nums[index++] = nums[i];\n            }\n        }\n        return index;\n    }\n}\n```\n### [Majority Element](https://leetcode-cn.com/problems/majority-element/)\n思路：设置变量majority存储可能是众数的元素，设置一个计数器count对元素的出现次数进行计数，在遍历数组的过程操作count变量进行一些操作。\n```java\nclass Solution {\n    public int majorityElement(int[] nums) {\n        int count = 0;\n        int majority = nums[0];\n        for (int i = 0; i < nums.length; i++) {\n            if (count == 0) majority = nums[i];\n            if (majority == nums[i]) count++;\n            else {\n                count--;\n            }\n        }\n        return majority;\n    }\n}\n```\n### [Search a 2D Matrix](https://leetcode-cn.com/problems/search-a-2d-matrix/)\n[Search a 2D Matrix II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)\n思路：根据题目的条件可知数组是有规律的，按照规律以某个元素所在行和列进行搜索，而减少对整个数组进行搜索。每个元素的行和列构成递增序列。\n```java\nclass Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        int rows = matrix.length;\n        if (rows == 0) return false;\n        int cols = matrix[0].length;\n        int i = 0, j = cols - 1;  //右上角第一个元素的坐标\n        while (i < rows && j >= 0) {\n            if (matrix[i][j] == target) {\n                return true;\n            } else if (matrix[i][j] > target) {\n                j--;\n            } else {\n                i++;\n            }\n        }\n        return false;\n    }\n}\n```\n### [Move Zeroes](https://leetcode-cn.com/problems/move-zeroes/)\n思路：先将前面非零数字进行填充，将数组之后空的位置填充上零。\n```java\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int index = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] != 0) {\n                nums[index++] = nums[i];\n            }\n        }\n        for (int i = index; i < nums.length; i++) {\n            nums[i] = 0;\n        }\n    }\n}\n```\n### [Intersection of Two Arrays](https://leetcode-cn.com/problems/intersection-of-two-arrays/)\n思路：通过java提供的数据结构Set来帮助简化我们做题，用contains()方法啊，使得我们不用再去写遍历操作\n```java\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        Set<Integer> set = new HashSet<>();\n        Set<Integer> res = new HashSet<>();\n        for(int n : nums1)\n            set.add(n);\n        for(int n : nums2)\n            if(set.contains(n))\n                res.add(n);\n        int[] result = new int[res.size()];\n        int index = 0 ;\n        for(int n : res)\n            result[index++] = n;\n        return result;\n    }\n}\n```\n### [Intersection of Two Arrays II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)\n思路：设置一个hash数组统计数组当中每个元素出现的次数。\n``` C++\nclass Solution {\n    public:\n    vector<int> intersect(vector<int>&nums1, vector<int>&nums2) {\n        vector<int> res;\n        map<int, int> mp;\n        for (int i = 0; i < nums1.size(); i++) {\n            mp[nums1[i]]++;\n        }\n        for (int i = 0; i < nums2.size(); i++) {\n            if (mp[nums2[i]] > 0) {\n                res.push_back(nums2[i]);\n                mp[nums2[i]]--;\n            }\n        }\n        return res;\n    }\n};\n```\n### [Kth Largest Element in an Array](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)\n思路：先进行排序，再得出结果\n```java\nclass Solution {\n    public int findKthLargest(int[] nums, int k) {\n        Arrays.sort(nums);\n        return nums[nums.length - k];\n    }\n}\n```\n## stack\n需要掌握的思想\n> * 模拟进出栈\n> * 用栈解决问题的思想\n### [Min Stack](https://leetcode-cn.com/problems/min-stack/submissions/)\n思路：用两个栈，一个栈为最小值栈，一个栈为真实数据栈。或者用一个栈也可以。\n```java\nclass MinStack {\n\n    /**\n     * initialize your data structure here.\n     */\n    private Stack<Integer> min, data; //min为最小值栈。\n\n    public MinStack() {  //初始化两个栈\n        min = new Stack<>();\n        data = new Stack<>();\n    }\n\n    public void push(int x) {\n        data.push(x);\n        if (min.empty() || min.peek() >= x) {\n            min.push(x);\n        }\n    }\n\n    public void pop() {\n        if ((int) data.peek() == (int) min.peek()) { //通过peek()方法返回的为对象，两个不同的对象进行比较总是不相等的，所以需要进行强转。\n            min.pop();\n        }\n        data.pop();\n    }\n\n    public int top() {\n        return data.peek();\n    }\n\n    public int getMin() {\n        return min.peek();\n    }\n}\n```\n## Tree\n### [Binary Tree Preorder Traversal](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)\n思路：非递归遍历，根据访问的顺序：根->左->右。\n```java\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        Stack<TreeNode> stack = new Stack<>();\n        if (root != null) stack.push(root);\n        while (!stack.empty()) {\n            TreeNode node = stack.pop();\n            res.add(node.val);\n            if (node.right != null) stack.push(node.right);//将还没访问的结点入栈\n            if (node.left != null) stack.push(node.left);\n        }\n        return res;\n    }\n}\n```\n递归写法：\n```java\nclass Solution {\n    List<Integer> list = new ArrayList<>();\n\n    public List<Integer> preorderTraversal(TreeNode root) {\n        if (root == null) {\n            return list;\n        }\n        list.add(root.val);\n        preorderTraversal(root.left);\n        preorderTraversal(root.right);\n        return list;\n    }\n}\n```\n### [Binary Tree Inorder Traversal](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)\n非递归写法：\n```java\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        Stack<TreeNode> stack = new Stack<>();\n        TreeNode node = root;\n        while (!stack.empty() || node != null) {\n            if (node != null) {\n                stack.push(node);\n                node = node.left;\n            } else {\n                node = stack.pop();\n                res.add(node.val);\n                node = node.right;\n            }\n        }\n        return res;\n    }\n}\n```\n递归写法：\n```java\nclass Solution {\n    List<Integer> list = new ArrayList();\n\n    public List<Integer> inorderTraversal(TreeNode root) {\n        if (root == null) {\n            return list;\n        }\n        inorderTraversal(root.left);\n        list.add(root.val);\n        inorderTraversal(root.right);\n        return list;\n    }\n}\n```\n### [Binary Tree Postorder Traversal](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)\n非递归写法：\n```java\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        Stack<TreeNode> stack = new Stack<>();\n        TreeNode p = root, q = null;\n        do {\n            while (p != null) {  //将左边的结点全部压入栈\n                stack.push(p);\n                p = p.left;\n            }\n            q = null;\n            while (!stack.empty()) {  //查看出栈结点的右结点是否为空\n                p = stack.pop();\n                if (p.right == q) {\n                    res.add(p.val);\n                    q = p;\n                } else {\n                    stack.push(p);\n                    p = p.right; //转换成右边的结点\n                    break;\n                }\n            }\n        } while (!stack.empty());\n        return res;\n    }\n}\n```\n递归写法：\n```java\nclass Solution {\n    List<Integer> list = new ArrayList<>();\n\n    public List<Integer> postorderTraversal(TreeNode root) {\n        if (root == null) {\n            return list;\n        }\n        postorderTraversal(root.left);\n        postorderTraversal(root.right);\n        list.add(root.val);\n        return list;\n    }\n}\n```\n### [Kth Smallest Element in a BST](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)\n思路：根据二叉搜索树的特性，选择用中序遍历的思想，设置变量统计当前访问到的结点，如果与所求结点k相等，则返回。\n```java\nclass Solution {\n    int count = 0;\n    TreeNode res;\n\n    public int kthSmallest(TreeNode root, int k) {\n        InorderTraversal(root, k);\n        return res.val;\n    }\n\n    public void InorderTraversal(TreeNode root, int k) {\n        if (root.left != null) InorderTraversal(root.left, k);\n        count++;\n        if (count == k) {\n            res = root;\n            return;\n        }\n        if (root.right != null) InorderTraversal(root.right, k);\n    }\n}\n```\n### [Lowest Common Ancestor of a Binary Tree](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)\n递归时需要建立总体的观念\n```java\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null || p == root || q == root) return root;  //当p和q当中有一个为根结点，则返回根结点\n        TreeNode left = lowestCommonAncestor(root.left, p, q); //递归时需要建立全局的观念\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\n        if(left!=null&&right!=null) return root; //若p、q在分在左右子树之间，则返回根结点\n        return left!=null ? left:right; //若p、q同在左子树或者右子树，则返回不为空的结点\n    }\n}\n```\n### [Binary Tree Level Order Traversal]()\n思路：使用深度优先遍历或者辅助队列\n```\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<>();\n        dfs(root,0,res);\n        return res;\n    }\n\n    public void dfs(TreeNode root, int depth, List<List<Integer>> res) {\n        if (root != null) {\n            if (res.size() < depth + 1) {\n                res.add(depth, new ArrayList<Integer>());\n            }\n            res.get(depth).add(root.val);\n            depth++;\n            if(root.left!=null) dfs(root.left,depth,res);\n            if(root.right!=null) dfs(root.right,depth,res);\n        }\n    }\n}\n```\n### [Binary Tree Level Order Traversal II]()\n思路：和上一题的思路是一致的，只是在最后加入结果集时需要将其插入到头部。\n```\nclass Solution {\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\n        LinkedList<List<Integer>> res = new LinkedList<>();\n        if (root == null) return res;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            List<Integer> list = new ArrayList<>();\n            for (int i = queue.size(); i > 0; i--) {\n                TreeNode node = queue.poll();\n                list.add(node.val);\n                if (node.left != null) queue.offer(node.left);\n                if (node.right != null) queue.offer(node.right);\n            }\n            res.offerFirst(list); //将其插入到链表的头部\n        }\n        return res;\n    }\n}\n```\n### [Average of Levels in Binary Tree]()\n```\nclass Solution {\n    public List<Double> averageOfLevels(TreeNode root) {\n        List<Double> res = new LinkedList<>();\n        if (root == null) return res;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            double sum = 0;\n            for (int i = size; i > 0; i--) {\n                TreeNode node = queue.poll();\n                if (node != null) sum += node.val;\n                if (node.left != null) queue.add(node.left);\n                if (node.right != null) queue.add(node.right);\n            }\n            res.add(sum / size);\n        }\n        return res;\n    }\n}\n```\n\n### [N-ary Tree Level Order Traversal]()\n递归算法：\n```\nclass Solution {\n    public List<List<Integer>> levelOrder(Node root) {\n        List<List<Integer>> res = new ArrayList<>();\n        dfs(root, 0, res);\n        return res;\n    }\n\n    public void dfs(Node root, int depth, List<List<Integer>> res) {\n        if (root != null) {\n            if (res.size() < depth + 1) {  //根据层数判断需要创建多少个的List\n                res.add(depth, new ArrayList<Integer>());\n            }\n            res.get(depth).add(root.val);    //从特殊情况->一般情况\n            depth++;\n            for (Node child : root.children) {\n                dfs(child, depth, res);\n            }\n        }\n    }\n}\n```\n非递归算法：\n```\nclass Solution {\n    public List<List<Integer>> levelOrder(Node root) {\n        List<List<Integer>> res = new ArrayList<>();\n        if (root == null) return res;\n        Queue<Node> queue = new LinkedList<>();\n        queue.add(root);\n        while (!queue.isEmpty()) {\n            List<Integer> list = new ArrayList<>();\n            for (int i = queue.size(); i > 0; i--) {  //一开始就必须获得队列的大小（队列是在不断变化的），队列当中当前层的全部结点\n                Node node = queue.poll();\n                list.add(node.val);\n                for (Node child : node.children) {\n                    queue.add(child);\n                }\n            }\n            res.add(list);\n        }\n        return res;\n    }\n}\n```\n### [Path Sum ]()\n```\nclass Solution {\n    public boolean hasPathSum(TreeNode root, int sum) {\n        if (root == null)\n            return false;\n        sum -= root.val;\n        if (root.right == null && root.left == null) return sum == 0; //判断最后根节点到叶子结点的路径和是否为零。\n        return hasPathSum(root.left, sum) || hasPathSum(root.right, sum);\n    }\n```\n### [Path Sum II]()\n```\nclass Solution {\n    public List<List<Integer>> pathSum(TreeNode root, int sum) {\n        List<List<Integer>> res = new ArrayList<>();\n        helper(res,new ArrayList<>(),root,sum);\n        return res;\n    }\n\n    public void helper(List<List<Integer>> res, List<Integer> list, TreeNode root, int sum) {\n        if (root == null) return;\n        list.add(root.val);\n        if (root.left == null && root.right == null && root.val == sum) {\n            res.add(new ArrayList<>(list));\n        }\n        helper(res,list,root.left,sum-root.val);\n        helper(res,list,root.right,sum-root.val);\n        list.remove(list.size()-1); //进行回溯。\n    }\n}\n```\n### [Path Sum III]()\n思路：1.计算以某个结点为路径起始点的符合条件数。2.遍历所有的结点，并递归执行1步骤。\n```\nclass Solution {\npublic:\n    int pathSum(TreeNode* root, int sum) { //遍历每个结点，每个结点都作为根计算路径\n        if (root == NULL) return 0;\n        return helper(root, sum) + pathSum(root -> left, sum) + pathSum(root -> right, sum);\n    }\n\n    int helper(TreeNode* root, int sum) { //以root为根作为一条路径，计算该路径上符合条件的数目\n        if (root == NULL) return 0;\n        sum -= root -> val; //sum为0的情况下即是符合路径\n        return (sum == 0 ? 1 : 0) + helper(root -> left, sum) + helper(root -> right, sum);\n    }\n};\n```\n## 递归\n### [反转字符串](https://leetcode.com/problems/reverse-string/)\n```\nclass Solution {\n    public void reverseString(char[] s) {\n        swap(0, s.length - 1, s);\n    }\n\n    public void swap(int start, int end, char[] s) {\n        if (start >= end) {  //递归边界\n            return;\n        }\n        char tmp = s[start];\n        s[start] = s[end];\n        s[end] = tmp;\n        swap(start + 1, end - 1, s);\n    }\n}\n```\n### [两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs)\n``` java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {  //递归边界\n            return head;\n        }\n        ListNode next = head.next;  //递归体\n        head.next = swapPairs(next.next);\n        next.next = head;\n        return next;\n    }\n}\n```","content":"<hr>\n<a id=\"more\"></a>\n<h2 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h2><p>常用的解题方法</p>\n<blockquote>\n<ul>\n<li>遍历链表</li>\n<li>利用递归的思想，如反转链表</li>\n<li>双指针：快慢指针</li>\n</ul>\n</blockquote>\n<h3 id=\"Remove-Duplicates-from-Sorted-List\"><a href=\"#Remove-Duplicates-from-Sorted-List\" class=\"headerlink\" title=\"Remove Duplicates from Sorted List\"></a><a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list\" target=\"_blank\" rel=\"noopener\">Remove Duplicates from Sorted List</a></h3><p>思路：遍历链表，在遍历时判断当前结点的值与后面结点的值是否相等，时间复杂度O(n)。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">deleteDuplicates</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        ListNode cur = head; <span class=\"comment\">//cur为遍历指针</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur != <span class=\"keyword\">null</span>&amp;&amp;cur.next != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cur.val == cur.next.val)&#123;</span><br><span class=\"line\">                cur.next = curt.next.next;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                cur = cur.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Remove-Duplicates-from-Sorted-List-II\"><a href=\"#Remove-Duplicates-from-Sorted-List-II\" class=\"headerlink\" title=\"Remove Duplicates from Sorted List II\"></a><a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/\" target=\"_blank\" rel=\"noopener\">Remove Duplicates from Sorted List II</a></h3><p>思路：采用双指针，一个指针指向需要保留的结点，一个指针对有重复值的结点进行查找。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">deleteDuplicates</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    ListNode dummy = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">    dummy.next = head; <span class=\"comment\">//创建一个虚的头结点，方便后续的操作判断</span></span><br><span class=\"line\">    ListNode pre = dummy,cur = head;<span class=\"comment\">//双指针，pre指向需要保留的结点，cur为查重指针</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cur != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur.next != <span class=\"keyword\">null</span>&amp;&amp;cur.val == cur.next.val)&#123; <span class=\"comment\">//如果出现相等的结点，就把当前指针指到相等结点的最后一个,注意：并没有删除结点</span></span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pre.next == cur) &#123;  <span class=\"comment\">//说明这是一个有唯一值的结点，cur指针还没有动过呢,通过cur指针是否有移动来判断是否存在等值结点</span></span><br><span class=\"line\">            pre = pre.next;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span>&#123;    <span class=\"comment\">//如果有一堆相等的结点，那就进行批量的删除</span></span><br><span class=\"line\">            pre.next = cur.next; <span class=\"comment\">//这边pre指针没有动过哦，只是修改它指向的下一个的结点</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur = cur.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dummy.next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Linked-List-Cycle\"><a href=\"#Linked-List-Cycle\" class=\"headerlink\" title=\"Linked List Cycle\"></a><a href=\"https://leetcode-cn.com/problems/linked-list-cycle\" target=\"_blank\" rel=\"noopener\">Linked List Cycle</a></h3><p>思路：采用快慢指针的思想。如果存在环，快指针终归会追上慢指针<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    ListNode fast,slow;</span><br><span class=\"line\">    fast=slow = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast != <span class=\"keyword\">null</span> &amp;&amp; fast.next != <span class=\"keyword\">null</span>)&#123; <span class=\"comment\">//注意这边判断的写法，同时对前后两个结点进行判断</span></span><br><span class=\"line\">       fast = fast.next.next;<span class=\"comment\">//fast每次走两步，slow每次走一步</span></span><br><span class=\"line\">       slow = slow.next;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(fast == slow) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Linked-List-Cycle-II\"><a href=\"#Linked-List-Cycle-II\" class=\"headerlink\" title=\"Linked List Cycle II\"></a><a href=\"https://leetcode-cn.com/problems/linked-list-cycle-ii/\" target=\"_blank\" rel=\"noopener\">Linked List Cycle II</a></h3><p>思路：与上题的思想基本一致。只是…看图：<br><img src=\"/uploads/LinkList.jpg\" alt=\"explanation\"><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">detectCycle</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        ListNode fast, slow;</span><br><span class=\"line\">        fast = slow = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (fast != <span class=\"keyword\">null</span> &amp;&amp; fast.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fast == slow) &#123;</span><br><span class=\"line\">                fast = head;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (fast != slow) &#123;</span><br><span class=\"line\">                    fast = fast.next;</span><br><span class=\"line\">                    slow = slow.next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> fast;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Odd-Even-Linked-List\"><a href=\"#Odd-Even-Linked-List\" class=\"headerlink\" title=\"Odd Even Linked List\"></a><a href=\"https://leetcode-cn.com/problems/odd-even-linked-list/\" target=\"_blank\" rel=\"noopener\">Odd Even Linked List</a></h3><p>思路：采用双指针的思想，可以想象成分成两个链表，一个下标为偶数的链表，一个下标为奇数的链表，pre、cur分别指向两个链表的末尾结点。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">oddEvenList</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>||head.next.next==<span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> head; <span class=\"comment\">//结点为空，一个结点，两个结点的情况</span></span><br><span class=\"line\">        ListNode pre = head, cur = head.next;<span class=\"comment\">//pre指向偶数链表的末结点，cur指向奇数链表的末结点。</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur != <span class=\"keyword\">null</span> &amp;&amp; cur.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ListNode tmp = pre.next; <span class=\"comment\">//先保存要拼接的结点</span></span><br><span class=\"line\">            pre.next = cur.next;</span><br><span class=\"line\">            cur.next = cur.next.next; <span class=\"comment\">//每次只进行一个结点的连接</span></span><br><span class=\"line\">            pre.next.next=tmp;  <span class=\"comment\">//进行拼接</span></span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">            pre = pre.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Palindrome-Linked-List\"><a href=\"#Palindrome-Linked-List\" class=\"headerlink\" title=\"Palindrome Linked List\"></a><a href=\"https://leetcode-cn.com/problems/palindrome-linked-list/\" target=\"_blank\" rel=\"noopener\">Palindrome Linked List</a></h3><p>思路：使用快慢指针和栈。通过快指针可以知道慢指针什么时候遍历到了中点。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        ListNode slow = head, fast = head;</span><br><span class=\"line\">        Stack&lt;Integer&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        stack.push(head.val);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (fast.next != <span class=\"keyword\">null</span> &amp;&amp; fast.next.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">            stack.push(slow.val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fast.next == <span class=\"keyword\">null</span>) stack.pop();<span class=\"comment\">//结点为奇数个的时候，需要将一个结点先弹出</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (slow.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = stack.pop();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tmp != slow.val) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Intersection-of-Two-Linked-Lists\"><a href=\"#Intersection-of-Two-Linked-Lists\" class=\"headerlink\" title=\"Intersection of Two Linked Lists\"></a><a href=\"https://leetcode-cn.com/problems/intersection-of-two-linked-lists/\" target=\"_blank\" rel=\"noopener\">Intersection of Two Linked Lists</a></h3><p>思路：一种方法是求得两条链表的结点个数差n，然后让长的链先走n，然后再同时遍历，比较两个结点的地址是相等。另一种方法是：通过环的思想，进行交叉遍历，让两个指针都走完相同的路程。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (headA == <span class=\"keyword\">null</span> || headB == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        ListNode p = headA, q = headB;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != q) &#123;</span><br><span class=\"line\">            p = p == <span class=\"keyword\">null</span> ? headB : p.next;</span><br><span class=\"line\">            q = q == <span class=\"keyword\">null</span> ? headA : q.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Sort-List\"><a href=\"#Sort-List\" class=\"headerlink\" title=\"Sort List\"></a><a href=\"https://leetcode-cn.com/problems/sort-list/\" target=\"_blank\" rel=\"noopener\">Sort List</a></h3><p>思路：采用快慢指针查找到中间结点，进行递归的归并排序<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">sortList</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        ListNode pre = head, slow = head, fast = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (fast != <span class=\"keyword\">null</span> &amp;&amp; fast.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            pre = slow;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> merge(sortList(head), sortList(slow));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ListNode <span class=\"title\">merge</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l1 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l2 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class=\"line\">            l1.next = merge(l1.next, l2);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            l2.next = merge(l1, l2.next);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Delete-Node-in-a-Linked-List\"><a href=\"#Delete-Node-in-a-Linked-List\" class=\"headerlink\" title=\"Delete Node in a Linked List\"></a><a href=\"https://leetcode-cn.com/problems/delete-node-in-a-linked-list/\" target=\"_blank\" rel=\"noopener\">Delete Node in a Linked List</a></h3><p>思路：将要删除的结点的值设为下个结点的值，将下个结点删除。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteNode</span><span class=\"params\">(ListNode node)</span> </span>&#123;</span><br><span class=\"line\">        ListNode q = node.next;</span><br><span class=\"line\">        node.val = q.val;</span><br><span class=\"line\">        node.next = q.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h2><p>常用的解题方法</p>\n<blockquote>\n<ul>\n<li>运用哈希</li>\n<li>使用双指针</li>\n</ul>\n</blockquote>\n<h3 id=\"反转字符串-II\"><a href=\"#反转字符串-II\" class=\"headerlink\" title=\" 反转字符串 II\"></a><a href=\"https://leetcode-cn.com/problems/reverse-string-ii\" target=\"_blank\" rel=\"noopener\"> 反转字符串 II</a></h3><p>思路：每隔2k个字符开始遍历，然后进行反转。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">reverseStr</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.size(); i += <span class=\"number\">2</span> * k) &#123;</span><br><span class=\"line\">            reverse(s.begin() + i, min(s.begin() + i + k, s.end())); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Implement-strStr\"><a href=\"#Implement-strStr\" class=\"headerlink\" title=\"Implement strStr()\"></a><a href=\"https://leetcode-cn.com/problems/implement-strstr/\" target=\"_blank\" rel=\"noopener\">Implement strStr()</a></h3><p>思想：1.暴力破解，如果发生不匹配主串可能需要回溯。2.KMP算法。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">strStr</span><span class=\"params\">(String haystack, String needle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len1 = haystack.length(), len2 = needle.length();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; len1 &amp;&amp; j &lt; len2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (haystack.charAt(i) == needle.charAt(j)) &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                i = i - j + <span class=\"number\">1</span>;</span><br><span class=\"line\">                j = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j &gt;= len2) <span class=\"keyword\">return</span> i - j;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Valid-Anagram\"><a href=\"#Valid-Anagram\" class=\"headerlink\" title=\"Valid Anagram\"></a><a href=\"https://leetcode-cn.com/problems/valid-anagram/\" target=\"_blank\" rel=\"noopener\">Valid Anagram</a></h3><p>思想：创建一个哈希数组，如果两个字符串含有同样的单词则将该位置的值置为0。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAnagram</span><span class=\"params\">(String s, String t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length() != t.length()) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || t == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] map = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">256</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            map[s.charAt(i)]++;</span><br><span class=\"line\">            map[t.charAt(i)]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Integer i : map) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Valid-Palindrome\"><a href=\"#Valid-Palindrome\" class=\"headerlink\" title=\"Valid Palindrome\"></a><a href=\"https://leetcode-cn.com/problems/valid-palindrome/\" target=\"_blank\" rel=\"noopener\">Valid Palindrome</a></h3><p>思路：采用双指针的思想，在这当中，使用了java提供的一些函数。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.trim().isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = s.length() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt; r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Character.isLetterOrDigit(s.charAt(l))) &#123; <span class=\"comment\">//非字母或者数字的情况下。</span></span><br><span class=\"line\">                l++;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Character.isLetterOrDigit(s.charAt(r))) &#123;</span><br><span class=\"line\">                r--;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Character.toLowerCase(s.charAt(l)) == Character.toLowerCase(s.charAt(r))) &#123;</span><br><span class=\"line\">                l++;</span><br><span class=\"line\">                r--;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Array\"><a href=\"#Array\" class=\"headerlink\" title=\"Array\"></a>Array</h2><p>常用的解题方法</p>\n<blockquote>\n<ul>\n<li>遍历数组，标记变量</li>\n<li>双指针</li>\n</ul>\n</blockquote>\n<h3 id=\"39-Combination-Sum\"><a href=\"#39-Combination-Sum\" class=\"headerlink\" title=\"39. Combination Sum\"></a><a href>39. Combination Sum</a></h3><p>主要思路：递归、回溯。画出图可以帮助理解。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    private List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); //用于保存结果</span><br><span class=\"line\">    private Stack&lt;Integer&gt; pre = new Stack&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    private void findCombinationSum(int start, int residue, int[] candidates, Stack&lt;Integer&gt; pre) &#123;</span><br><span class=\"line\">        if (residue == 0) &#123;</span><br><span class=\"line\">            res.add(new ArrayList&lt;&gt;(pre));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for (int i = start; i &lt; candidates.length &amp;&amp; residue - candidates[i] &gt;= 0; i++) &#123;</span><br><span class=\"line\">            pre.add(candidates[i]);</span><br><span class=\"line\">            findCombinationSum(i, residue - candidates[i], candidates, pre);</span><br><span class=\"line\">            pre.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class=\"line\">        Arrays.sort(candidates);</span><br><span class=\"line\">        findCombinationSum(0, target, candidates, pre);</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"40-Combination-Sum-II\"><a href=\"#40-Combination-Sum-II\" class=\"headerlink\" title=\"40. Combination Sum II\"></a><a href>40. Combination Sum II</a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    private List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); //保存结果的数组</span><br><span class=\"line\">    private Stack&lt;Integer&gt; pre = new Stack&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    private void findCombinationSum(int start, int residue, int[] candidates, Stack&lt;Integer&gt; pre) &#123;</span><br><span class=\"line\">        if (residue == 0) &#123;</span><br><span class=\"line\">            res.add(new ArrayList&lt;&gt;(pre));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for (int i = start; i &lt; candidates.length &amp;&amp; residue - candidates[i] &gt;= 0; i++) &#123;</span><br><span class=\"line\">            if (i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) &#123;</span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            pre.add(candidates[i]);</span><br><span class=\"line\">            findCombinationSum(i + 1, residue - candidates[i], candidates, pre);</span><br><span class=\"line\">            pre.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;</span><br><span class=\"line\">        Arrays.sort(candidates);</span><br><span class=\"line\">        findCombinationSum(0, target, candidates, pre);</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"PascalsTriangle\"><a href=\"#PascalsTriangle\" class=\"headerlink\" title=\"PascalsTriangle\"></a><a href=\"https://leetcode-cn.com/problems/pascals-triangle/\" target=\"_blank\" rel=\"noopener\">PascalsTriangle</a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (int i = 0; i &lt; numRows; i++) &#123;</span><br><span class=\"line\">            List&lt;Integer&gt; row = new ArrayList&lt;&gt;();</span><br><span class=\"line\">            for (int j = 0; j &lt;= i; j++) &#123;</span><br><span class=\"line\">                if (i == 0 || j == 0 || i == j) &#123;</span><br><span class=\"line\">                    row.add(1);</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    List&lt;Integer&gt; pre = res.get(i - 1);</span><br><span class=\"line\">                    row.add(pre.get(j - 1) + pre.get(j));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res.add(row);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Remove-Duplicates-from-Sorted-Array\"><a href=\"#Remove-Duplicates-from-Sorted-Array\" class=\"headerlink\" title=\"Remove Duplicates from Sorted Array\"></a><a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/\" target=\"_blank\" rel=\"noopener\">Remove Duplicates from Sorted Array</a></h3><p>思路：使用双指针，一个指针为遍历指针；另一个指针指向结果数组的每个位置，判断该位置要填充的元素。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">removeDuplicates</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] != nums[index]) &#123;</span><br><span class=\"line\">                nums[++index] = nums[i];<span class=\"comment\">//0号位置的值已经确定，从1号位置开始</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> index + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Remove-Duplicates-from-Sorted-Array-II\"><a href=\"#Remove-Duplicates-from-Sorted-Array-II\" class=\"headerlink\" title=\"Remove Duplicates from Sorted Array II\"></a><a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/\" target=\"_blank\" rel=\"noopener\">Remove Duplicates from Sorted Array II</a></h3><p>思路：同上题的思路相同，只是多一个变量count对元素的数量进行统计。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">removeDuplicates</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>, count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[index] == nums[i]) &#123;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (count &lt; <span class=\"number\">2</span>) nums[++index] = nums[i];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                count = <span class=\"number\">0</span>;</span><br><span class=\"line\">                nums[++index] = nums[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> index + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Remove-Element\"><a href=\"#Remove-Element\" class=\"headerlink\" title=\"Remove Element\"></a><a href=\"https://leetcode-cn.com/problems/remove-element/\" target=\"_blank\" rel=\"noopener\">Remove Element</a></h3><p>思路：双指针，在遍历时用另一个指针确定结果数组的每一个位置的最终值<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">removeElement</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] != val) &#123;</span><br><span class=\"line\">                nums[index++] = nums[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Majority-Element\"><a href=\"#Majority-Element\" class=\"headerlink\" title=\"Majority Element\"></a><a href=\"https://leetcode-cn.com/problems/majority-element/\" target=\"_blank\" rel=\"noopener\">Majority Element</a></h3><p>思路：设置变量majority存储可能是众数的元素，设置一个计数器count对元素的出现次数进行计数，在遍历数组的过程操作count变量进行一些操作。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> majority = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count == <span class=\"number\">0</span>) majority = nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (majority == nums[i]) count++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                count--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> majority;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Search-a-2D-Matrix\"><a href=\"#Search-a-2D-Matrix\" class=\"headerlink\" title=\"Search a 2D Matrix\"></a><a href=\"https://leetcode-cn.com/problems/search-a-2d-matrix/\" target=\"_blank\" rel=\"noopener\">Search a 2D Matrix</a></h3><p><a href=\"https://leetcode-cn.com/problems/search-a-2d-matrix-ii/\" target=\"_blank\" rel=\"noopener\">Search a 2D Matrix II</a><br>思路：根据题目的条件可知数组是有规律的，按照规律以某个元素所在行和列进行搜索，而减少对整个数组进行搜索。每个元素的行和列构成递增序列。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">searchMatrix</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] matrix, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rows = matrix.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rows == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cols = matrix[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = cols - <span class=\"number\">1</span>;  <span class=\"comment\">//右上角第一个元素的坐标</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; rows &amp;&amp; j &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (matrix[i][j] == target) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (matrix[i][j] &gt; target) &#123;</span><br><span class=\"line\">                j--;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Move-Zeroes\"><a href=\"#Move-Zeroes\" class=\"headerlink\" title=\"Move Zeroes\"></a><a href=\"https://leetcode-cn.com/problems/move-zeroes/\" target=\"_blank\" rel=\"noopener\">Move Zeroes</a></h3><p>思路：先将前面非零数字进行填充，将数组之后空的位置填充上零。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">moveZeroes</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                nums[index++] = nums[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            nums[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Intersection-of-Two-Arrays\"><a href=\"#Intersection-of-Two-Arrays\" class=\"headerlink\" title=\"Intersection of Two Arrays\"></a><a href=\"https://leetcode-cn.com/problems/intersection-of-two-arrays/\" target=\"_blank\" rel=\"noopener\">Intersection of Two Arrays</a></h3><p>思路：通过java提供的数据结构Set来帮助简化我们做题，用contains()方法啊，使得我们不用再去写遍历操作<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] intersection(<span class=\"keyword\">int</span>[] nums1, <span class=\"keyword\">int</span>[] nums2) &#123;</span><br><span class=\"line\">        Set&lt;Integer&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        Set&lt;Integer&gt; res = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n : nums1)</span><br><span class=\"line\">            set.add(n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n : nums2)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(set.contains(n))</span><br><span class=\"line\">                res.add(n);</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[res.size()];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span> ;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n : res)</span><br><span class=\"line\">            result[index++] = n;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Intersection-of-Two-Arrays-II\"><a href=\"#Intersection-of-Two-Arrays-II\" class=\"headerlink\" title=\"Intersection of Two Arrays II\"></a><a href=\"https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/\" target=\"_blank\" rel=\"noopener\">Intersection of Two Arrays II</a></h3><p>思路：设置一个hash数组统计数组当中每个元素出现的次数。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; intersect(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp;nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp;nums2) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; mp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums1.size(); i++) &#123;</span><br><span class=\"line\">            mp[nums1[i]]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums2.size(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mp[nums2[i]] &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                res.push_back(nums2[i]);</span><br><span class=\"line\">                mp[nums2[i]]--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Kth-Largest-Element-in-an-Array\"><a href=\"#Kth-Largest-Element-in-an-Array\" class=\"headerlink\" title=\"Kth Largest Element in an Array\"></a><a href=\"https://leetcode-cn.com/problems/kth-largest-element-in-an-array/\" target=\"_blank\" rel=\"noopener\">Kth Largest Element in an Array</a></h3><p>思路：先进行排序，再得出结果<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        Arrays.sort(nums);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[nums.length - k];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"stack\"><a href=\"#stack\" class=\"headerlink\" title=\"stack\"></a>stack</h2><p>需要掌握的思想</p>\n<blockquote>\n<ul>\n<li>模拟进出栈</li>\n<li>用栈解决问题的思想</li>\n</ul>\n</blockquote>\n<h3 id=\"Min-Stack\"><a href=\"#Min-Stack\" class=\"headerlink\" title=\"Min Stack\"></a><a href=\"https://leetcode-cn.com/problems/min-stack/submissions/\" target=\"_blank\" rel=\"noopener\">Min Stack</a></h3><p>思路：用两个栈，一个栈为最小值栈，一个栈为真实数据栈。或者用一个栈也可以。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MinStack</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * initialize your data structure here.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;Integer&gt; min, data; <span class=\"comment\">//min为最小值栈。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MinStack</span><span class=\"params\">()</span> </span>&#123;  <span class=\"comment\">//初始化两个栈</span></span><br><span class=\"line\">        min = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        data = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        data.push(x);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (min.empty() || min.peek() &gt;= x) &#123;</span><br><span class=\"line\">            min.push(x);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((<span class=\"keyword\">int</span>) data.peek() == (<span class=\"keyword\">int</span>) min.peek()) &#123; <span class=\"comment\">//通过peek()方法返回的为对象，两个不同的对象进行比较总是不相等的，所以需要进行强转。</span></span><br><span class=\"line\">            min.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        data.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">top</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getMin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> min.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Tree\"><a href=\"#Tree\" class=\"headerlink\" title=\"Tree\"></a>Tree</h2><h3 id=\"Binary-Tree-Preorder-Traversal\"><a href=\"#Binary-Tree-Preorder-Traversal\" class=\"headerlink\" title=\"Binary Tree Preorder Traversal\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-preorder-traversal/\" target=\"_blank\" rel=\"noopener\">Binary Tree Preorder Traversal</a></h3><p>思路：非递归遍历，根据访问的顺序：根-&gt;左-&gt;右。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root != <span class=\"keyword\">null</span>) stack.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack.empty()) &#123;</span><br><span class=\"line\">            TreeNode node = stack.pop();</span><br><span class=\"line\">            res.add(node.val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.right != <span class=\"keyword\">null</span>) stack.push(node.right);<span class=\"comment\">//将还没访问的结点入栈</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.left != <span class=\"keyword\">null</span>) stack.push(node.left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>递归写法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        list.add(root.val);</span><br><span class=\"line\">        preorderTraversal(root.left);</span><br><span class=\"line\">        preorderTraversal(root.right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Binary-Tree-Inorder-Traversal\"><a href=\"#Binary-Tree-Inorder-Traversal\" class=\"headerlink\" title=\"Binary Tree Inorder Traversal\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/\" target=\"_blank\" rel=\"noopener\">Binary Tree Inorder Traversal</a></h3><p>非递归写法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        TreeNode node = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack.empty() || node != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                stack.push(node);</span><br><span class=\"line\">                node = node.left;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                node = stack.pop();</span><br><span class=\"line\">                res.add(node.val);</span><br><span class=\"line\">                node = node.right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>递归写法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        inorderTraversal(root.left);</span><br><span class=\"line\">        list.add(root.val);</span><br><span class=\"line\">        inorderTraversal(root.right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Binary-Tree-Postorder-Traversal\"><a href=\"#Binary-Tree-Postorder-Traversal\" class=\"headerlink\" title=\"Binary Tree Postorder Traversal\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-postorder-traversal/\" target=\"_blank\" rel=\"noopener\">Binary Tree Postorder Traversal</a></h3><p>非递归写法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        TreeNode p = root, q = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span>) &#123;  <span class=\"comment\">//将左边的结点全部压入栈</span></span><br><span class=\"line\">                stack.push(p);</span><br><span class=\"line\">                p = p.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            q = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!stack.empty()) &#123;  <span class=\"comment\">//查看出栈结点的右结点是否为空</span></span><br><span class=\"line\">                p = stack.pop();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p.right == q) &#123;</span><br><span class=\"line\">                    res.add(p.val);</span><br><span class=\"line\">                    q = p;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    stack.push(p);</span><br><span class=\"line\">                    p = p.right; <span class=\"comment\">//转换成右边的结点</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (!stack.empty());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>递归写法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        postorderTraversal(root.left);</span><br><span class=\"line\">        postorderTraversal(root.right);</span><br><span class=\"line\">        list.add(root.val);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Kth-Smallest-Element-in-a-BST\"><a href=\"#Kth-Smallest-Element-in-a-BST\" class=\"headerlink\" title=\"Kth Smallest Element in a BST\"></a><a href=\"https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/\" target=\"_blank\" rel=\"noopener\">Kth Smallest Element in a BST</a></h3><p>思路：根据二叉搜索树的特性，选择用中序遍历的思想，设置变量统计当前访问到的结点，如果与所求结点k相等，则返回。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    TreeNode res;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">kthSmallest</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        InorderTraversal(root, k);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">InorderTraversal</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.left != <span class=\"keyword\">null</span>) InorderTraversal(root.left, k);</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count == k) &#123;</span><br><span class=\"line\">            res = root;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.right != <span class=\"keyword\">null</span>) InorderTraversal(root.right, k);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Lowest-Common-Ancestor-of-a-Binary-Tree\"><a href=\"#Lowest-Common-Ancestor-of-a-Binary-Tree\" class=\"headerlink\" title=\"Lowest Common Ancestor of a Binary Tree\"></a><a href=\"https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/\" target=\"_blank\" rel=\"noopener\">Lowest Common Ancestor of a Binary Tree</a></h3><p>递归时需要建立总体的观念<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span> || p == root || q == root) <span class=\"keyword\">return</span> root;  <span class=\"comment\">//当p和q当中有一个为根结点，则返回根结点</span></span><br><span class=\"line\">        TreeNode left = lowestCommonAncestor(root.left, p, q); <span class=\"comment\">//递归时需要建立全局的观念</span></span><br><span class=\"line\">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left!=<span class=\"keyword\">null</span>&amp;&amp;right!=<span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> root; <span class=\"comment\">//若p、q在分在左右子树之间，则返回根结点</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> left!=<span class=\"keyword\">null</span> ? left:right; <span class=\"comment\">//若p、q同在左子树或者右子树，则返回不为空的结点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Binary-Tree-Level-Order-Traversal\"><a href=\"#Binary-Tree-Level-Order-Traversal\" class=\"headerlink\" title=\"Binary Tree Level Order Traversal\"></a><a href>Binary Tree Level Order Traversal</a></h3><p>思路：使用深度优先遍历或者辅助队列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        dfs(root,0,res);</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void dfs(TreeNode root, int depth, List&lt;List&lt;Integer&gt;&gt; res) &#123;</span><br><span class=\"line\">        if (root != null) &#123;</span><br><span class=\"line\">            if (res.size() &lt; depth + 1) &#123;</span><br><span class=\"line\">                res.add(depth, new ArrayList&lt;Integer&gt;());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res.get(depth).add(root.val);</span><br><span class=\"line\">            depth++;</span><br><span class=\"line\">            if(root.left!=null) dfs(root.left,depth,res);</span><br><span class=\"line\">            if(root.right!=null) dfs(root.right,depth,res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Binary-Tree-Level-Order-Traversal-II\"><a href=\"#Binary-Tree-Level-Order-Traversal-II\" class=\"headerlink\" title=\"Binary Tree Level Order Traversal II\"></a><a href>Binary Tree Level Order Traversal II</a></h3><p>思路：和上一题的思路是一致的，只是在最后加入结果集时需要将其插入到头部。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class=\"line\">        LinkedList&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();</span><br><span class=\"line\">        if (root == null) return res;</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class=\"line\">        queue.offer(root);</span><br><span class=\"line\">        while (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">            for (int i = queue.size(); i &gt; 0; i--) &#123;</span><br><span class=\"line\">                TreeNode node = queue.poll();</span><br><span class=\"line\">                list.add(node.val);</span><br><span class=\"line\">                if (node.left != null) queue.offer(node.left);</span><br><span class=\"line\">                if (node.right != null) queue.offer(node.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res.offerFirst(list); //将其插入到链表的头部</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Average-of-Levels-in-Binary-Tree\"><a href=\"#Average-of-Levels-in-Binary-Tree\" class=\"headerlink\" title=\"Average of Levels in Binary Tree\"></a><a href>Average of Levels in Binary Tree</a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public List&lt;Double&gt; averageOfLevels(TreeNode root) &#123;</span><br><span class=\"line\">        List&lt;Double&gt; res = new LinkedList&lt;&gt;();</span><br><span class=\"line\">        if (root == null) return res;</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class=\"line\">        queue.add(root);</span><br><span class=\"line\">        while (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            int size = queue.size();</span><br><span class=\"line\">            double sum = 0;</span><br><span class=\"line\">            for (int i = size; i &gt; 0; i--) &#123;</span><br><span class=\"line\">                TreeNode node = queue.poll();</span><br><span class=\"line\">                if (node != null) sum += node.val;</span><br><span class=\"line\">                if (node.left != null) queue.add(node.left);</span><br><span class=\"line\">                if (node.right != null) queue.add(node.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res.add(sum / size);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"N-ary-Tree-Level-Order-Traversal\"><a href=\"#N-ary-Tree-Level-Order-Traversal\" class=\"headerlink\" title=\"N-ary Tree Level Order Traversal\"></a><a href>N-ary Tree Level Order Traversal</a></h3><p>递归算法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        dfs(root, 0, res);</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void dfs(Node root, int depth, List&lt;List&lt;Integer&gt;&gt; res) &#123;</span><br><span class=\"line\">        if (root != null) &#123;</span><br><span class=\"line\">            if (res.size() &lt; depth + 1) &#123;  //根据层数判断需要创建多少个的List</span><br><span class=\"line\">                res.add(depth, new ArrayList&lt;Integer&gt;());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res.get(depth).add(root.val);    //从特殊情况-&gt;一般情况</span><br><span class=\"line\">            depth++;</span><br><span class=\"line\">            for (Node child : root.children) &#123;</span><br><span class=\"line\">                dfs(child, depth, res);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>非递归算法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        if (root == null) return res;</span><br><span class=\"line\">        Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();</span><br><span class=\"line\">        queue.add(root);</span><br><span class=\"line\">        while (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">            for (int i = queue.size(); i &gt; 0; i--) &#123;  //一开始就必须获得队列的大小（队列是在不断变化的），队列当中当前层的全部结点</span><br><span class=\"line\">                Node node = queue.poll();</span><br><span class=\"line\">                list.add(node.val);</span><br><span class=\"line\">                for (Node child : node.children) &#123;</span><br><span class=\"line\">                    queue.add(child);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res.add(list);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Path-Sum\"><a href=\"#Path-Sum\" class=\"headerlink\" title=\"Path Sum \"></a><a href>Path Sum </a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public boolean hasPathSum(TreeNode root, int sum) &#123;</span><br><span class=\"line\">        if (root == null)</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        sum -= root.val;</span><br><span class=\"line\">        if (root.right == null &amp;&amp; root.left == null) return sum == 0; //判断最后根节点到叶子结点的路径和是否为零。</span><br><span class=\"line\">        return hasPathSum(root.left, sum) || hasPathSum(root.right, sum);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Path-Sum-II\"><a href=\"#Path-Sum-II\" class=\"headerlink\" title=\"Path Sum II\"></a><a href>Path Sum II</a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        helper(res,new ArrayList&lt;&gt;(),root,sum);</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void helper(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, TreeNode root, int sum) &#123;</span><br><span class=\"line\">        if (root == null) return;</span><br><span class=\"line\">        list.add(root.val);</span><br><span class=\"line\">        if (root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == sum) &#123;</span><br><span class=\"line\">            res.add(new ArrayList&lt;&gt;(list));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        helper(res,list,root.left,sum-root.val);</span><br><span class=\"line\">        helper(res,list,root.right,sum-root.val);</span><br><span class=\"line\">        list.remove(list.size()-1); //进行回溯。</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Path-Sum-III\"><a href=\"#Path-Sum-III\" class=\"headerlink\" title=\"Path Sum III\"></a><a href>Path Sum III</a></h3><p>思路：1.计算以某个结点为路径起始点的符合条件数。2.遍历所有的结点，并递归执行1步骤。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int pathSum(TreeNode* root, int sum) &#123; //遍历每个结点，每个结点都作为根计算路径</span><br><span class=\"line\">        if (root == NULL) return 0;</span><br><span class=\"line\">        return helper(root, sum) + pathSum(root -&gt; left, sum) + pathSum(root -&gt; right, sum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    int helper(TreeNode* root, int sum) &#123; //以root为根作为一条路径，计算该路径上符合条件的数目</span><br><span class=\"line\">        if (root == NULL) return 0;</span><br><span class=\"line\">        sum -= root -&gt; val; //sum为0的情况下即是符合路径</span><br><span class=\"line\">        return (sum == 0 ? 1 : 0) + helper(root -&gt; left, sum) + helper(root -&gt; right, sum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><h3 id=\"反转字符串\"><a href=\"#反转字符串\" class=\"headerlink\" title=\"反转字符串\"></a><a href=\"https://leetcode.com/problems/reverse-string/\" target=\"_blank\" rel=\"noopener\">反转字符串</a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public void reverseString(char[] s) &#123;</span><br><span class=\"line\">        swap(0, s.length - 1, s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void swap(int start, int end, char[] s) &#123;</span><br><span class=\"line\">        if (start &gt;= end) &#123;  //递归边界</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        char tmp = s[start];</span><br><span class=\"line\">        s[start] = s[end];</span><br><span class=\"line\">        s[end] = tmp;</span><br><span class=\"line\">        swap(start + 1, end - 1, s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"两两交换链表中的节点\"><a href=\"#两两交换链表中的节点\" class=\"headerlink\" title=\"两两交换链表中的节点\"></a><a href=\"https://leetcode-cn.com/problems/swap-nodes-in-pairs\" target=\"_blank\" rel=\"noopener\">两两交换链表中的节点</a></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">swapPairs</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) &#123;  <span class=\"comment\">//递归边界</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode next = head.next;  <span class=\"comment\">//递归体</span></span><br><span class=\"line\">        head.next = swapPairs(next.next);</span><br><span class=\"line\">        next.next = head;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","slug":"leetcode题解","excerpt":"","categories":[{"name":"Data Structure & Algorithm","slug":"Data-Structure-Algorithm","permalink":"http://yoursite.com/categories/Data-Structure-Algorithm/"}],"tags":[]}]}